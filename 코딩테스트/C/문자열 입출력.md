> char str[32] 

문자열은 항상 **가변길이** 임을 인지 

똑같이 bufferd i/o이다  

메모리에 저장되는 것이고 끝은 항상 **null** 이게 문자열의 끝임을 알린다 

배열이다

왜냐 char가 여러개가 모인게 문자열이니까 

>gets() 는 보안 결함 문제가 있어서 사용하지 않는다

> puts() 는 문자열 출력에 사용되지만 자동 개행이된다


# gets()

매개변수로 메모리의 주소를 받는다 

일단 문자열을 입력받을 때 길이를 모른다 
즉 고정길이인 메모리에 가변길이인 문자열을 할당하는 것 

고정길이인 메모리를 초과해서 입력하면 => 오버플로우가 발생한다 

> 메모리 경계를 벗어난 쓰기를 수행


# gets_s(변수이름,사이즈)

> gets_s(szName,sizeOf(szName));

이거는 넘어가서 쓰는 걸 막아준다

# fgets(변수이름,사이즈,stdin 등)

리눅스에서 쓰는 것 출력을


# 입력받기

## Scanf_s 사용하자

```c
char szName[32] = { 0 };
int age = 0;
printf("나이를 입력하세요: ");
scanf_s("%d%*c", &age);

printf("이름을 입력하세요: ");
gets_s(szName, sizeof(szName));

printf("%d세 %s \n", age, szName);


return 0;


```

이렇게 scanf_s에 나이부분처럼 하게 되면 엔터키가 자동으로 삭제되어 진다 

그래서 gets_s에서 엔터키가 안먹고 된다 

> scanf_s("%d\n")

이런거 하면 안된다 개행이 스캔에 안들어가게 조심해야된다 

# 문자열 처리

문자는 기본적으로 숫자 
A = 65

> strtok_s (대상문자열,기준,그다음문자열)

스트링토크나이저
문자열을 자르는 것 

하지만 이거 진행하면 계속해서 내가 기준으로 선택한것에 null을 입력시킴 

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


int main(void) {
	char szBuffer[128] = { "nData = x + y;\nnResult = a * b" };
	char* sep = " *+=;\n";
	char* token = NULL;
	char* nextToken = NULL;

	token = strtok_s(szBuffer, sep, &nextToken);
	while (token != NULL) {
		puts(token);
		token = strtok_s(NULL, sep, &nextToken);
	}

	printf("\nBuffer : %s ", szBuffer);
	return 0;
}
```

# 가변 길이에 의한 stack frame 손상 

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
void get(void) {
	char szBuffer[8] = { 0 };
	int nData = 0x11223344;
	gets(szBuffer);
	printf("%s,%08X\n", szBuffer, nData);
	return;
}

int main(void) {
	get();
	return 0;
}
```