# char [] vs char * 


char [] 은 이 자체로 문자열을 그대로 저장하는 것 
char * 는 문자열이 저장되어있는 주소를 저장하는 것
그래서 가변길이 상관없이 쉽게 표현이 가능하것이다 
char []이거는 길이를 고정시켜야되서 불편하다 


> char str[32] 
> 

문자열은 항상 **가변길이** 임을 인지 

똑같이 bufferd i/o이다  

메모리에 저장되는 것이고 끝은 항상 **null** 이게 문자열의 끝임을 알린다 

배열이다

왜냐 char가 여러개가 모인게 문자열이니까 

>gets() 는 보안 결함 문제가 있어서 사용하지 않는다

> puts() 는 문자열 출력에 사용되지만 자동 개행이된다


# gets()

매개변수로 메모리의 주소를 받는다 

일단 문자열을 입력받을 때 길이를 모른다 
즉 고정길이인 메모리에 가변길이인 문자열을 할당하는 것 

고정길이인 메모리를 초과해서 입력하면 => 오버플로우가 발생한다 

> 메모리 경계를 벗어난 쓰기를 수행


# gets_s(변수이름,사이즈)

> gets_s(szName,sizeOf(szName));

이거는 넘어가서 쓰는 걸 막아준다

# fgets(변수이름,사이즈,stdin 등)

리눅스에서 쓰는 것 출력을


# 입력받기

## Scanf_s 사용하자

```c
char szName[32] = { 0 };
int age = 0;
printf("나이를 입력하세요: ");
scanf_s("%d%*c", &age);

printf("이름을 입력하세요: ");
gets_s(szName, sizeof(szName));

printf("%d세 %s \n", age, szName);


return 0;


```

이렇게 scanf_s에 나이부분처럼 하게 되면 엔터키가 자동으로 삭제되어 진다 

그래서 gets_s에서 엔터키가 안먹고 된다 

> scanf_s("%d\n")

이런거 하면 안된다 개행이 스캔에 안들어가게 조심해야된다 

# 문자열 처리

문자는 기본적으로 숫자 
A = 65

> strtok_s (대상문자열,기준,그다음문자열)

스트링토크나이저
문자열을 자르는 것 

하지만 이거 진행하면 계속해서 내가 기준으로 선택한것에 null을 입력시킴 

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


int main(void) {
	char szBuffer[128] = { "nData = x + y;\nnResult = a * b" };
	char* sep = " *+=;\n";
	char* token = NULL;
	char* nextToken = NULL;

	token = strtok_s(szBuffer, sep, &nextToken);
	while (token != NULL) {
		puts(token);
		token = strtok_s(NULL, sep, &nextToken);
	}

	printf("\nBuffer : %s ", szBuffer);
	return 0;
}
```

# 가변 길이에 의한 stack frame 손상 

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
void get(void) {
	char szBuffer[8] = { 0 };
	int nData = 0x11223344;
	gets(szBuffer);
	printf("%s,%08X\n", szBuffer, nData);
	return;
}

int main(void) {
	get();
	return 0;
}
```
![[Drawing 2024-03-18 14.22.23.excalidraw]]

이렇게 보면 지금 nullnull총 8글자를 입력하여 마지막 널이 nData영역을 침범하여 44가 오버라이딩 된것을 볼수 있다 


# atoi()

> 문자열을 integer로 바꾸겠다

범위문제만 신경쓰기

integer 최대수 +1 하면 그냥 최대수가 출력된다 



# rand(),srand()

## srand()
rand()함수에 사용될 수를 초기화하는 것 

seed라고 한다 

하지만 seed 값이 같으면 rand() 했을 때 일정한 값이 계속 똑같이 나온다

그렇기에 *seed 값은 계속 변하는 값이여야된다*

> seed 값을 **Time**으로 주자 !!

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


int main(void) {
	int i = 0;
	srand((unsigned)time(NULL));

	for (i = 0; i < 10; i++) {
		printf("%6d\n", rand() % 10);
	}
	return 0;
}
```

# system()

시스템상에서 코드를 실행하는 것 

그래서 보안상 바이러스코드를 실행시킬수도 있어서 위험하다 


# exit()

이걸 호출하면 그냥 바로 즉시 끝남 프로그램이 