메모리 종류
- stack 지역변수(자동변수) 보통 1MB
- Heap 동적할당 메모리
- 실행코드
	- text (기계어)
	- data section 
		- read only(문자열 상수)
		- Read/Write(정적 메모리 ) = 여기가 전역변수 


메모리 관리 함수 
- malloc 
- free

malloc 같은 것으로 os한테 요청하면 os가 메모리 영역 할당해서 준다 

그 대신 free를 해줘야됨 높은 자유로 메모리를 건드리지만 그만큼 책임도 크다 

# 정적 메모리 할당 vs 동적 메모리 할당

## 정적 메모리 할당
- 컴파일타임에 메모리 크기를 할당해준 것
- 실해중에는 크기는 안바뀐다
- 크기만 컴파일 타임에 할당되고 런타임에 실제 메모리의 위치가 결정난다 
- 
# 포인터 변수

메모리 주소를 저장하기 위한 전용변수 
주소는 결국 위치정보 메모리에 어디에 위치해야있는지 

64bit 시스템에서는 주소 상수,포인터 변수는 모두 64bit(8 bytess)

1byte의 char형 변수의 메모리 주소는 64bit

## 직접지정 간접지정 

특정 메모리 공간을 int로 지정할 때 상수로 지정하면 직접지정 

포인터 변수로 지정하면 간접지정 


```c
#include <stdio.h>

int main(void) {

	int nData = 10;

	printf("%s\n", "nData");

	printf("%d\n", nData);
	printf("%p\n", &nData);

	return 0;
}
```

이렇게 하고 f9로 브레이크 포인트 걸고 실행시키다가 alt+8하면 
디스어셈블리가 보인다 그리고 마지막에 nData의 주소를 찍어보면 
매번 실행마다 주소가 다르게 찍힌다 

## 메모리는 매 실행마다 다르다 
### 즉 실행 때 결정된다 

보안 때문에 **ASLR**
> Address Space Layout Random 

운영체제에서 보안 이유로 실행마다 바꾼다 

> [!example]
> 게임에서 체력 정보 변수의 메모리 위치를 알아내서 1부터 100까지를 10만까지 바꿔서 해킹 가능 


# 포인터와 1차원 배열 

인덱스는 기준으로 부터 상대적인 위치 

char[] 는 char 스타로 관리
```c
*가 간접 지정 연산자
#include<stdio.h> 
int main(void) { 
int x = 10; // 변수 x를 가리키는 int형식에 대한 포인터 변수 선언 및 정의 // pnData 에 x의 주소가 저장 
int* pnData = &x; 
printf("x : %d\n", x); // pnData 포인터 변수가 가리키는 대상 메모리를 int형 변수로 간접지정하고 20을 대입한다. // 현재 가리키는 대상 메모리는 변수 x의 메모리이므로 x의 값은 20이 된다. 
*pnData = 20; 
printf("x : %d\n", x); 
return 0; 
}

```

간접 지정 연산자로 변수로 간주가 가능 

포인터 변수나 배열의 이름에 대해서 덧셈 뺼셈 가능 

> 곱하기 나누기는 불가능하다 

상대 위치를 계산하기 위한 연산 
포인터 변수에 대해서 단항 증 감 연산도 가능 

예를 들어서 
```c

int aList[2] = {0,1};

*(aList+1) = 2 ;

//이렇게 하면 aList[1]은 2가 된다 
```

```c

배열의 길이 확인하는 코딩 

#include <stdio.h>

int main(void) {
	char nData[10] = "hello";

	char* pData = nData;

	while (*pData != '\0')
		pData++;

	printf("Length : %d", pData - nData);

	return 0;
}
```


이게 strlen 함수
# 메모리 동적 할당 및 예제 


결국 개발의 시점으로 돌아가서 

Compile + Link는 개발 단계이고 그 다음이 Runtime 

그래서 개발 할 때는 runtime을 어느정도 예상해서 개발해야한다 

> Heap 영역을 사용한다 
> 자유메모리 공간 

## os에게 요청해서 사용한다음 반환의 책임이 있다

할당 요청시 받을 만큼의 공간을 요청해야한다.

할당 받은 메모리는 쓰레기 값이 들어있다
- 그래서 쓰레기 값을 **Clear**하려고 하지만 이건 상황마다 다르다 
- 크기가 작은 공간이면 0클리어 해도 괜찮지만 
- 1gb등 동영상 처리 시스템에서는 클리어하면 너무 오래걸린다 
- 그러므로 항상 클리어하는게 아니라 쓰레기값인걸 인지하고 프로그래밍을 잘하자 

### 할당 
> malloc() 위치 정보를 반환한다

### 반납 
> free()


```c
#include <stdio.h>
#include <stdlib.h>
int main(void) {
	int* pList = NULL;

	pList = (int*)malloc(sizeof(int) * 3);
	
	pList[0] = 10;
	pList[1] = 20;
	pList[2] = 30;


	return 0;
}
```

malloc 쓸려고 할경우에는 꼭 
헤더파일을 include해주자 
![[Pasted image 20240308212505.png]]

또한 이렇게 할당받으면 공간만큼에 cd가 채워져서 있고 그 위아래로 fd가 채워져 있다 

이처럼 메모리를 할당받으면 실제로 그 크기보다 더 많이 할당받고 free할경우에도 더 많은 범위 만큼 반환해 버린다 os 내부에서 

아마 fd 는 카나리 값 인것 같다 

 > [!tip]
 > canary 값 
 > BOF(buffer overflow) 공격을 방지하기 위해서 넣는 값들
 
 근데 그림처럼 저렇게 4byte 만큼 canary값이 있으면 저기에 write가 가능은 하다 하지만 오류가 발생한다 heap corruption이 
 

# 메모리 초기화 복사 비교
메모리 초기화 할 경우에 
무조건 0초기화를 할 필요는 없다 
만약에 문자열을 저장할거면 그럴 경우에는 0초기화를 해준다.


# 문자열 복사 비교 검색 
```c
#include <stdio.h>
#include <stdlib.h>
int main(void) {

	char szBuffer[] = { "hello" };
	char* pszBuffer = szBuffer;

	char* pzHeap = malloc(16);
	strcpy_s(pzHeap, 16, szBuffer);

	puts(pzHeap);
	free(pzHeap);
	return 0;
}
```

여기서 strcpy_s 는 deep copy이기 때 메모리 주소를 단순히 복사하는게 아니라 메모리에 저장된 값을 볷하한다 

그러므로 만약에 
> pzHeap = pszBuffer 

했을 경우에는 szBuffer의 0 번 인덱스의 메모리 주소를 가르키게 되므로 안된다 

## 문자열 비교 
> strcmp (비교하는 문자열,문자열) 아니면 포인터면 그 변수명 가능 배열도 가능 

앞이 크면 1 같으면 0 작으면 -1

## 문자열 검색

> strstr(주소,검색어(여기에는 char[],아니면 문자열 상수))


```c

printf("%d",strstr(szBuffer,"am")-szBuffer);
```

이렇게 하는 이유는 strstr은 주소를 반환해주기에 am은 무조건 szBuffer의 0번째 인덱스보다 크기에 그 주소의 차이만큼 빼주면 인덱스가 된다 

## 문자열도 결국 가변+배열(pointer)


# 동적 할당된 메모리 구조와 realloc()

malloc()은 조금 느리다 

운영체제가 만약에 내가 처음에 16짜리를 쓰다가 free하고 
나중에 15만큼을 요청하면 그냥 새롭게 chunk를 만드는게 아니라 16짜리를 주는게 오히려 더 효율적일 수도 있다 

이처럼 만약에 15를 요청했는데 20공간을 할당했을 가능성이 존재한다

이런경우 메모리 크기 조정이 가능한 것 

크기를 키워서 다시 할당해 달라고

## realloc()
> [!d] realloc() 
> 기존에 받은 메모리 크기를 조정해 다시 할당 하려고 할 경우
> 메모리 chunk 크기 조절에 실패할 경우에는 전혀 새로운 위치로 이동 될 수 있다 

> 보통 크기 증가 요청 

실제로는 이 함수를 안쓴다
그 이유가 뭐냐 하면 이렇게 크기 조절이 실패할 경우 아예 새로운 공간으로 할당 받는데 그럼 그 과정에서 기존 내용이 그대로 메모리 복사가 일어나기에 당연히 메모리 접근해서 복사하는 과정은 너무 느리다 



# 다중 포인터 

```c
*(char *) == char
*(char **) == char*
```

```c
int main(void) {

	char* li[3] = { "hello","world","new" };

	printf("%s\n", li[0]);
	printf("%s\n", li[1]);
	printf("%s\n", li[2]);

	printf("%s\n", li[0]+1);
	printf("%s\n", li[1]+1);
	printf("%s\n", li[2]+1);

	printf("%c\n", li[0][1]);
	printf("%c\n", li[2][2]);
	printf("%c\n", li[2][2]);


	return 0;
}
```

여기서 저 배열은 pointer이 배열이다 
그러므로 %s는 주소와 매핑되는거이기에 li[0]의 주소의 문자열을 찍어줄 것이고 li[0] +1 도 결국 pointer+1이니까 결과처럼 출력되는 것이다.

![[Pasted image 20240312185735.png]]


# 다차원 배열 포인터
```c
char a[2][12];
// 이게 char 12개를 요소로 같지는 배열이다
char (*pa) [12] = a;
```

이렇게 해야 된다 
그래야
요소가 char [12]인 배열에 대한 포인터가 된다 

# 정적 메모리와 기억부류 지정자
Stack 
- 자동변수 보통 1MB
Heap
- 동적할당 메모리
실행코드
- text section( 실행 코드 기계어 )
- data section 
	- readonly(문자열 상수)
	- read/write(정적 메모리) = 전역변수

## 기억 부류 지정자

> extern,auto,static,register

스태틱은 정적메모리 

동시성 이슈가 있음

정적 메모리 잘못 사용시 멀티 쓰레드에서 문제 발생 

전역 변수도 동시성 문제 발생 가능성 

register cpu의 register를 사용하게 하는데 일반적으로 아예 접근이 안됨 임베디드 쪽에서나 가능 


## 정적 변수 

![[Pasted image 20240315192910.png]]

여기서 보면 static으로 선언한 D의 변수의 메모리상 주소가 
어셈블리어 ( alt + 8) 로 열어서 확인한 기계어 주소와 비슷한 모습인 것을 보면 
실행코드 내부에 정적영역이 있는 것을 알수있다

> 정적변수나 전역변수는 백퍼센트 동시성 이슈 날 수 있다 

함수 내부에  정적변수 static은 동시성이 그냥 안된다 
