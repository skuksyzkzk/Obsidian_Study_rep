메모리 종류
- stack 지역변수(자동변수) 보통 1MB
- Heap 동적할당 메모리
- 실행코드
	- text (기계어)
	- data section 
		- read only(문자열 상수)
		- Read/Write(정적 메모리 ) = 여기가 전역변수 


메모리 관리 함수 
- malloc 
- free

malloc 같은 것으로 os한테 요청하면 os가 메모리 영역 할당해서 준다 

그 대신 free를 해줘야됨 높은 자유로 메모리를 건드리지만 그만큼 책임도 크다 

# 포인터 변수

메모리 주소를 저장하기 위한 전용변수 
주소는 결국 위치정보 메모리에 어디에 위치해야있는지 

64bit 시스템에서는 주소 상수,포인터 변수는 모두 64bit(8 bytess)

1byte의 char형 변수의 메모리 주소는 64bit

## 직접지정 간접지정 

특정 메모리 공간을 int로 지정할 때 상수로 지정하면 직접지정 

포인터 변수로 지정하면 간접지정 


```c
#include <stdio.h>

int main(void) {

	int nData = 10;

	printf("%s\n", "nData");

	printf("%d\n", nData);
	printf("%p\n", &nData);

	return 0;
}
```

이렇게 하고 f9로 브레이크 포인트 걸고 실행시키다가 alt+8하면 
디스어셈블리가 보인다 그리고 마지막에 nData의 주소를 찍어보면 
매번 실행마다 주소가 다르게 찍힌다 

## 메모리는 매 실행마다 다르다 
### 즉 실행 때 결정된다 

보안 때문에 **ASLR**
> Address Space Layout Random 

운영체제에서 보안 이유로 실행마다 바꾼다 

> [!example]
> 게임에서 체력 정보 변수의 메모리 위치를 알아내서 1부터 100까지를 10만까지 바꿔서 해킹 가능 


# 포인터와 1차원 배열 

인덱스는 기준으로 부터 상대적인 위치 

char[] 는 char 스타로 관리
```c
*가 간접 지정 연산자
#include<stdio.h> 
int main(void) { 
int x = 10; // 변수 x를 가리키는 int형식에 대한 포인터 변수 선언 및 정의 // pnData 에 x의 주소가 저장 
int* pnData = &x; 
printf("x : %d\n", x); // pnData 포인터 변수가 가리키는 대상 메모리를 int형 변수로 간접지정하고 20을 대입한다. // 현재 가리키는 대상 메모리는 변수 x의 메모리이므로 x의 값은 20이 된다. 
*pnData = 20; 
printf("x : %d\n", x); 
return 0; 
}

```

간접 지정 연산자로 변수로 간주가 가능 

포인터 변수나 배열의 이름에 대해서 덧셈 뺼셈 가능 

> 곱하기 나누기는 불가능하다 

상대 위치를 계산하기 위한 연산 
포인터 변수에 대해서 단항 증 감 연산도 가능 

예를 들어서 
```c

int aList[2] = {0,1};

*(aList+1) = 2 ;

//이렇게 하면 aList[1]은 2가 된다 
```

```c

배열의 길이 확인하는 코딩 

#include <stdio.h>

int main(void) {
	char nData[10] = "hello";

	char* pData = nData;

	while (*pData != '\0')
		pData++;

	printf("Length : %d", pData - nData);

	return 0;
}
```


이게 strlen 함수
# 메모리 동적 할당 및 예제 


결국 개발의 시점으로 돌아가서 

Compile + Link는 개발 단계이고 그 다음이 Runtime 

그래서 개발 할 때는 runtime을 어느정도 예상해서 개발해야한다 

> Heap 영역을 사용한다 
> 자유메모리 공간 

## os에게 요청해서 사용한다음 반환의 책임이 있다

할당 요청시 받을 만큼의 공간을 요청해야한다.

할당 받은 메모리는 쓰레기 값이 들어있다
- 그래서 쓰레기 값을 **Clear**하려고 하지만 이건 상황마다 다르다 
- 크기가 작은 공간이면 0클리어 해도 괜찮지만 
- 1gb등 동영상 처리 시스템에서는 클리어하면 너무 오래걸린다 
- 그러므로 항상 클리어하는게 아니라 쓰레기값인걸 인지하고 프로그래밍을 잘하자 

### 할당 
> malloc() 위치 정보를 반환한다

### 반납 
> free()


```c
#include <stdio.h>
#include <stdlib.h>
int main(void) {
	int* pList = NULL;

	pList = (int*)malloc(sizeof(int) * 3);
	
	pList[0] = 10;
	pList[1] = 20;
	pList[2] = 30;


	return 0;
}
```

malloc 쓸려고 할경우에는 꼭 
헤더파일을 include해주자 
![[Pasted image 20240308212505.png]]

또한 이렇게 할당받으면 공간만큼에 cd가 채워져서 있고 그 위아래로 fd가 채워져 있다 

이처럼 메모리를 할당받으면 실제로 그 크기보다 더 많이 할당받고 free할경우에도 더 많은 범위 만큼 반환해 버린다 os 내부에서 

아마 fd 는 카나리 값 인것 같다 

 > [!tip]
 > canary 값 
 > BOF(buffer overflow) 공격을 방지하기 위해서 넣는 값들
 
 근데 그림처럼 저렇게 4byte 만큼 canary값이 있으면 저기에 write가 가능은 하다 하지만 오류가 발생한다 heap corruption이 
 

# 메모리 초기화 복사 비교
메모리 초기화 할 경우에 
무조건 0초기화를 할 필요는 없다 
만약에 문자열을 저장할거면 그럴 경우에는 0초기화를 해준다.

