코드 덩어리 실행의 단위

> main은 무조건 있어야된다 자동으로 호풀되는 것 
> 진입점 entry point 

printf scanf 이것들도 다 c 런타임 라이브러리
라이브러리는 그냥 함수들이 잔뜩 들어간것 

Caller 가 호출자 함수
Calle가 피호출자 함수 

배열은 0번째 인덱스의 주소를 나타내는 것 이름이 

&로서 l value를 표현 가능하다 location나타내는 의미라고 하긴했는데

함수 이름 역시 주소를 나타낸다 
기계어가 나오는데 실행코드가 저장된 메모리의 주소 
실행코드를 바꾸면 안되니까 read only 기계어가 저장되어있음 


## 함수 호출시 
> nResult = add(3,4);

이거는 

nResult = 주소(3,4);랑 같다 함수이름은 주소이기에 그리고
()도 연산자이다 함수호출 연산자 

## 기초함수 설계원칙

1. ui와 기능은 반드시 분리 
	1. web이 front back 구분 잘되어있는 사례 
2. 재사용한 단위코드는 함수로 구현 
	1. dry 원칙 do not repeat your code 복붙하지마라 
	2. 왜냐 이러면 큰일난다 복붙해서 다쓰면 에러 발생시 큰일남
	3. 함수로 작성하면 함수만 고치면 나머지 부분도 수정되기에 


### ui와 기능을 분리 해야된다 

팩토리얼 구하는 함수에서 내부에서 -1을 입력값으로하면 안에서 prinft하는게 아니라 0을 리턴해서 main 쪽 즉 ui부분에서 처리하게 하는게 잘한 것이다 


# 이벤트 루프 구현 

이벤트  - 사용자의 입력에 의한것 

사용자의 입력때문에 이벤트가 발생한다 
발생하면 처리 해야된다 
## 함수 원형 선형과 분할 컴파일 

함수의 원형 선형 => 함수 시그니쳐 

int add(void);이것만 한것 

원형 선형을 하는 이유 -> 컴파일러에게 함수의 존재를 알리기 위해 
매개변수 이름 생략 가능 

링크작업이란게 

hello.c fun.c 이렇게 소스코드 파일이 2개 존재하면 그걸 묶어서 하나의 exe로 만들어 주는 작업이다 

그래서 분할 컴파일이란 예를들어 
hello.c에 메인에서 add를 호출하는데 선언만하고 정의를 fun.c에 해서 받아오는 것 그래서 2파일이 각각 오브젝트가 생성되고 동시에 exe로 합쳐지는 것이 분할 컴파일이다
만먁 둘다 add 함수가 있으면 오류가 발생한다 


## 전역변수와 지역변수 

접근성 범위로 분류

scope내에서만 유지되는게 지역변수
파일 내에서 유지는 전역변수 => 함수 바디에 선언 

> 전역변수는 사실 안쓰는게 좋다 꼭필요할때만 

지역변수는 자동변수 즉 stack을 사용한다 
하지만 전역변수는 정적인 영역을 사용하게됨 

전역변수 사용시 g_ 꼭 붙이자 


# 매개변수 전달 기법

인수,매개변수,파라미터,아규먼트 등은 다 같은말 

매개변수도 결국 변수다 

매개변수는 피호출함수에서 지역변수처럼 사용된다 

> 매개변수는 stack 영역 사용 
> 32비트에선 이말 맞다
> 64비트에선 register 사용 

![[Pasted image 20240315195710.png]]

이 그림 처럼 매개변수는 오른쪽부터 레지스터로 옮겨진다 

이처럼 64비트에서는 레지스터로 바로 입력됨 매개변수가 

## Call by value 
## Call by reference 

> 어떤함수가 다른 함수를 콜하고 어떻게 호출되는 지를 보려면 CallStack을 보면된다

 실제로 레지스터를 보면 반환할때
 eax 즉 rax 레지스터에 넣어서 반환한다
 ![[Pasted image 20240315200648.png]]

이렇게 그림처럼 return t 할때 eax 레지스터에 넣어서 반환한다
그렇기에 return 값이 하나 인것 
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int Test(int a,int b) {
	int t = 0;
	t = a + b;
	return t;
}

int main(void) {
	int c =Test(5, 10);

	return 0;
}
```

이렇게 매개변수로 값자체를 넘겨주는 것이 
*call by value*

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int Test(int* a,int* b) {
	int t = 0;
	t = *a + *b;
	return t;
}

int main(void) {
	int x = 5, y = 6;
	int c =Test(&x,&y);

	return 0;
}
```

이렇게 하는 것이  call by reference
왜 이렇게 사용할까?
즉 메모리를 건드리는 것 

메인함수에서 사용하는 스택영역의 메모리 주소를 넘겨서 
내가 가진 메모리에 대하여 접근한다음 계산을 해달라는 것 

> 데이터가 배열로 int [100]이래버리면 일일이 매개변수(value)로 넘겨줄수가없기때문에 실제로 배열의 이름은 주소상수 


