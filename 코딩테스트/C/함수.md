코드 덩어리 실행의 단위

> main은 무조건 있어야된다 자동으로 호풀되는 것 
> 진입점 entry point 

printf scanf 이것들도 다 c 런타임 라이브러리
라이브러리는 그냥 함수들이 잔뜩 들어간것 

Caller 가 호출자 함수
Calle가 피호출자 함수 

배열은 0번째 인덱스의 주소를 나타내는 것 이름이 

&로서 l value를 표현 가능하다 location나타내는 의미라고 하긴했는데

함수 이름 역시 주소를 나타낸다 
기계어가 나오는데 실행코드가 저장된 메모리의 주소 
실행코드를 바꾸면 안되니까 read only 기계어가 저장되어있음 


## 함수 호출시 
> nResult = add(3,4);

이거는 

nResult = 주소(3,4);랑 같다 함수이름은 주소이기에 그리고
()도 연산자이다 함수호출 연산자 

## 기초함수 설계원칙

1. ui와 기능은 반드시 분리 
	1. web이 front back 구분 잘되어있는 사례 
2. 재사용한 단위코드는 함수로 구현 
	1. dry 원칙 do not repeat your code 복붙하지마라 
	2. 왜냐 이러면 큰일난다 복붙해서 다쓰면 에러 발생시 큰일남
	3. 함수로 작성하면 함수만 고치면 나머지 부분도 수정되기에 


### ui와 기능을 분리 해야된다 

팩토리얼 구하는 함수에서 내부에서 -1을 입력값으로하면 안에서 prinft하는게 아니라 0을 리턴해서 main 쪽 즉 ui부분에서 처리하게 하는게 잘한 것이다 


# 이벤트 루프 구현 

이벤트  - 사용자의 입력에 의한것 

사용자의 입력때문에 이벤트가 발생한다 
발생하면 처리 해야된다 
## 함수 원형 선형과 분할 컴파일 

함수의 원형 선형 => 함수 시그니쳐 

int add(void);이것만 한것 

원형 선형을 하는 이유 -> 컴파일러에게 함수의 존재를 알리기 위해 
매개변수 이름 생략 가능 

링크작업이란게 

hello.c fun.c 이렇게 소스코드 파일이 2개 존재하면 그걸 묶어서 하나의 exe로 만들어 주는 작업이다 

그래서 분할 컴파일이란 예를들어 
hello.c에 메인에서 add를 호출하는데 선언만하고 정의를 fun.c에 해서 받아오는 것 그래서 2파일이 각각 오브젝트가 생성되고 동시에 exe로 합쳐지는 것이 분할 컴파일이다
만먁 둘다 add 함수가 있으면 오류가 발생한다 


## 전역변수와 지역변수 

접근성 범위로 분류

scope내에서만 유지되는게 지역변수
파일 내에서 유지는 전역변수 => 함수 바디에 선언 

> 전역변수는 사실 안쓰는게 좋다 꼭필요할때만 

지역변수는 자동변수 즉 stack을 사용한다 
하지만 전역변수는 정적인 영역을 사용하게됨 

전역변수 사용시 g_ 꼭 붙이자 


# 매개변수 전달 기법

인수,매개변수,파라미터,아규먼트 등은 다 같은말 

매개변수도 결국 변수다 

매개변수는 피호출함수에서 지역변수처럼 사용된다 

> 매개변수는 stack 영역 사용 
> 32비트에선 이말 맞다
> 64비트에선 register 사용 

![[Pasted image 20240315195710.png]]

이 그림 처럼 매개변수는 오른쪽부터 레지스터로 옮겨진다 

이처럼 64비트에서는 레지스터로 바로 입력됨 매개변수가 

## Call by value 
## Call by reference 

> 어떤함수가 다른 함수를 콜하고 어떻게 호출되는 지를 보려면 CallStack을 보면된다

 실제로 레지스터를 보면 반환할때
 eax 즉 rax 레지스터에 넣어서 반환한다
 ![[Pasted image 20240315200648.png]]

이렇게 그림처럼 return t 할때 eax 레지스터에 넣어서 반환한다
그렇기에 return 값이 하나 인것 
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int Test(int a,int b) {
	int t = 0;
	t = a + b;
	return t;
}

int main(void) {
	int c =Test(5, 10);

	return 0;
}
```

이렇게 매개변수로 값자체를 넘겨주는 것이 
*call by value*

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int Test(int* a,int* b) {
	int t = 0;
	t = *a + *b;
	return t;
}

int main(void) {
	int x = 5, y = 6;
	int c =Test(&x,&y);

	return 0;
}
```

이렇게 하는 것이  call by reference
왜 이렇게 사용할까?
즉 메모리를 건드리는 것 

메인함수에서 사용하는 스택영역의 메모리 주소를 넘겨서 
내가 가진 메모리에 대하여 접근한다음 계산을 해달라는 것 

> 데이터가 배열로 int [100]이래버리면 일일이 매개변수(value)로 넘겨줄수가없기때문에 실제로 배열의 이름은 주소상수 


# 예제 
두 char[]의 주소를 매개변수로 받아 문자열을 deep copy하는 
Mystrcpy() 함수를 작성. 함수의 두 번째 매개변수는 첫번째 매개변수의 메모리 크기가 되도록 구현 


```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
void Mystrcpy(char* dst,unsigned int size, char* src) {
	size_t nLenSrc = 0;
	nLenSrc = strlen(src);

	/*if (nLenSrc + 1 > size) {
		예외처리도 필요
	}*/
	for (int i = 0; i < nLenSrc; ++i) {
		dst[i] = src[i];
	}
}

int main(void) {
	char szBufferSrc[12] = { "TestString" };
	char szBufferDst[12] = { 0 };

	Mystrcpy(szBufferDst, sizeof(szBufferSrc), szBufferSrc);
	puts(szBufferDst);
	return 0;
}
```


# StackFrame과 지역변수 주소 반환 오류

Malloc하면 주소를 받는다 
함수 A가 동적할당받았고 return 해버리면 
과연 동적할당된 메모리는 그대로 있을까? 

그대로 있다 

## 지역변수 주소 반환 오류
- 피호출 함수의 지역변수는 함수의 반환과 함께 모두 소멸 
- 소멸된 메모리 영역의 주소를 호출자 함수에게 반환하고 접근하는 것은 매우 심각한 오류  

스택을 쓰는 애들은 함수를 반환하면 스택이 감소하고 줄어들고 사라진다 

사라지기로 되어있는 스택에 접근하면 어떻게 될까??

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int* Test(void) {
	int nData = 10;
	return &nData;
}

int main(void) {
	int* pnResult = NULL;
	pnResult = Test();

	printf("%d\n", *pnResult);
	return 0;
}
```

이렇게 실제론  nData는 스택영역에 있는거라 사라졌어야되는데 
실제로는 스택 1MB만큼 공간에서 안없어지고 그냥 쓰레기값으로 그 주소에 남아있어서 결과값이
10으로 정상출력된다

### 그러나 웃긴점

```c

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int* Test(void) {
	int nData = 10;
	return &nData;
}
int* Test2(void) {
	int a = 5;
	return NULL;
}

int main(void) {
	int* pnResult = NULL;
	pnResult = Test();
	Test2();
	printf("%d\n", *pnResult);
	return 0;
}
```

이렇게 중간에 Test2함수를 호출하면 결과값은 *5가된다*

 왜그럴까? 
 재사용한것 
 **그래서 지역변수의 주소를 반환하는 것을 절대 하지말자**


# call by reference와 동적메모리 할당이슈

메모리 동적 할당 및 해제와 함수 

## pointer 의 근본적 문제점 ! 

Callee 가 메모리를 동적 할당 한후 반환하는 구조는 문제여지 

주소를 Caller에게 반환하면  Caller가 접근가능

*문제점은 할당된 메모리 크기 전달 문제 고려 
사이즈를 알 수 가 없다*

Underflow Overflow 문제 

문자열 = 배열 = 가변길이
한글 2bytes


김성엽 6bytes

문자열은 기본적으로 가변길이
하지만 개발자는 문자열을 어느정도 특정해놔야된다

> 입력을 비정상적인 것들을 넣어봐서 테스트하는것 
> Fuzzing Test 


# 재귀 호출
	함수 코드 내부에서 다시 자신을 호출하는 것
	반복문과 Stack 자료구조를 합친것 

*비선형 자료구조에서 매우 중요하게 사용*

트리,그래프

## Stack을 왜 쓸까?

> 되돌아가려고

---
하지만 반복문은 당연히 오버플로우 문제 존재 


 