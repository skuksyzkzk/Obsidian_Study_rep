
# 형 한정어(type qualifier)

기본적으로 변수에 적용하는 문법 컴파일러 최적화와 깊이 관련

- const 
변수는 메모리를 쓴다 그 변수를 변경하지 못하게 하겠다
- 이게 컴파일러 최적화와 관련이 있음 
- 코드는 cpu 연산 

## const 
- 변수를 상수화
- 개념상 읽기 전용으로 만들어 준다
- 변수의 개수가 줄어들기 때문에 성능 최적화에 유리 

> 이름을 붙여서 의미를 부여한다 
> 읽기 좋은 코드를 만드는 좋은 방법론 중 하나

변수는 최대한 안쓸수있으면 줄여라 메모리 낮추기 위해서
복잡도를 떨어트린다 안쓰면 

# 릴리즈 빌드 vs 디버그 빌드

릴리즈 빌드는 최대한 메모리도 안쓰고 최적화 시킨다 

예를 들어서 

int a =3 ,b= 4;
int data =a+b;

data 출력하면 a와 b 변수 자체가 메모리에 안잡히고 그냥 7이 화면에 출련된다.

최적화에선 결국 의존관계를 파악하게된다 

변수들간의 의존관계

*형한정어는 많이 쓸수록 좋다*

## volatile

이렇게 선언하면 최적화 하지말아라 라고 하는 것 

volatile int a 이렇게 선언하면 a를 메모리에 잡아준다
제외 안하고 

*변수에는 이름이 붙는다 상수는 4,3이런건 의미가없다 *

# 심볼릭 상수 

> 프로그램 내부에서 특별한 의미를 갖는 기준값에 대해 이름을 부여한다 

읽기 좋은 코드를 만드는 법 

심볼릭 상수를 사용하거나 const 사용 
#define 으로도 사용 가능 

const 는 바로 코드에 적용 

> 합격 불합격은 결국 처리조건이다 

합격자 점수가 예를 들어 70점일수있는데 이게 변경될수도있다

점수 자체가 처리조건인것

이런 처리조건을 그럼 상수로 선언하는게 맞다 

상수에 의미가 부여되므로 편하다 


## 전처리기로 선언

```c

#define CUTOFF 32


```

이렇게 하면 컴파일할때 저 이름에 가면 32로 바꿔준다 


심볼릭 상수를 선언해서 쓰는게 좋다는 것 


# 상수형 포인터


### 매개변수 전달 기법
- ref -> 이건 포인터로 구현된다 

참조 관계가 변경이 될수가있다 

그래서 포인터를 상수화 시킨다

포인터 변수 자체를 상수화 

> Call by reference 상황에서 피호출자 함수에서 호출자가 제시한 메모리를 읽기 전용으로 차단이 된다 

원래는 매개변수로 포인터 보내면 write도 가능 

하지만 읽기전용이 되므로서 컴파일타임에 에러가 발생한다 

```c
void PrintString(const char* pszParam) {
    puts(pszParam);
}
```

이렇게 하는 이유도 그래서 
*매개변수에 저렇게 const를 넣어놓으면 단순하게 읽기만하고 수정못하고 프린트 하다는 것을 효과적으로 표현하는 거기도하다 *


# 열거형 상수

심볼릭 상수 선언하는 것이 3가지
- const 
- #define 
- 열거형 상수 

한번에 여러가지가 선언이 가능하고 
정수값으로 처리가 된다 


# 형 재선언 

typedef 

새로운 자료형을 선언하는 문법 
기본 자료형 기반으로 쓰는 거이긴하다 

*심볼릭 상수는 많이쓰는게 좋지만 형 재선언은 조심하자 *

얘를 들어 

```c
typedef const char* LPSTR
```

이렇게하면 char 포인터이다 
근데 쓸때는 LPSTR만 쓰니까 알 수 가없다 


# extern

변수 앞에서 붙는다

### 외부 변수 선언 

한개의 프로젝트 안에 A와 B가 있으면 A는 B의 외부이고 B는 A의 외부다 

A에서 B의 변수에 접근해야될경우 외부 변수 선언해야된다 

![[Pasted image 20240322204945.png]]



