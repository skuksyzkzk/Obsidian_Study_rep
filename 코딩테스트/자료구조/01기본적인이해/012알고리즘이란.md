
# 알고리즘
> 표현 및 저장된 데이터를 대상으로 하는 '문제의 해결 방법'

*자료구조에 따라서 알고리즘은 달라진다*
**알고리즘은 자료구조에 의존적이다**

# 시간 복잡도 vs 공간 복잡도 

그저 동작만 하는 자료구조와 알고리즘은 쉽다

동작 뿐 만아니라 *좋은 성능을 내는 것이 중요하다*

> 그렇기에 알고리즘을 분석하고 평가 가능해야된다

## 시간 복잡도
*어떤 알고리즘이 어떤 상황에서 더 빠르고 느리냐 

속도의 측면 

## 공간 복잡도 
*어떤 알고리즘이 어떤 상황에서 메모리를 적게 쓰느냐*

메모리 사용량의 측면 

사실 메모리 엑세스가 결국 시간이 오래걸리기에 이것도
시간과 관련되어있다는 것 



> 실행 속도에 보통 초점을 두고 평가 


속도를 평가하는 것은 

1. 연산의 횟수
2. 처리해야할 데이터 수 n에 대한 연산횟수의 함수 T(n)구성

연산의 횟수가 당연히 적을수록 빠르고 좋은 알고리즘이다

우리는 데이터 양의 변화에 따른 속도의 변화를 측정하여 평가해야되기에
함수로 만들면 데이터양의 변화에 따른 연산횟수 변화 정도 파악이 쉽다

![[Drawing 2024-03-22 18.42.23.excalidraw]]

이러한 그림에서는 데이터 양이적으면 지수함수가 좋고 
데이터양이 많아 질수록 일차함수가 좋다 이렇게 볼수있지만

이것도 맞긴하다
하지만 사실 데이터 양이 적을때는 속도차이가 나봐야 크지 않기 떄문에

*중요한 것은 데이터 수가 많아짐에 따른 연산횟수의 증가 정도에 있다*

일차함수 그래프가 훨씬 더 좋은 알고리즘이다 

# 순차 탐색 알고리즘과 시간복잡도

연산의 횟수를 센다고 하였으니 
어떠한 연산을 적게 수행하는 탐색 알고리즘이 좋을까? 

*핵심이 되는 연산이 적게 수행해야 된다*

> 중심이 되는 연산자에 주변 연산자는 의존적이다

순차 탐색에서는 탐색을 하는 거기에 비교연산자인 == 이 핵심연산자
+, >도 역시 ==가 True 이여야 되기에

- 최선의 경우
- 최악의 경우
- 평균적인 경우

최선의 경우는 상관 안한다. 어느 알고리즘이건 최선의 상황에서 좋다

> 평균적인 경우는 상황 연출이 힘들다 

최악은 항상 동일한 상황

평균적인 경우는 계산을 해도 증명이 힘들기에 잘 안쓴다

# 이진 탐색 알고리즘 소개 
> Binary Search 

조건
- 배열에 저장된 데이터는 정렬되어 있어야 한다
- 배열 인덱스 시작과 끝을 정하고
- 미드를 선택해서 값을 비교해서 똑같이 반복한다 

*탐색의 대상을 반복해서 반씩 떨구어 내는 알고리즘*

 first 가 last보다 큰 경우 탐색은 종료된다.

# 빅오표기법

읽을때 빅 오 오브 n2 이렇게 읽는다 
![[Pasted image 20240324212558.png]]


수학적인 접근
즉 *데이터 수의 증가에 따른 연산횟수 증가율의 상한선을 표현한것*



