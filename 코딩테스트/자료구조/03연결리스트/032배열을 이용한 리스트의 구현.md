
- 순차리스트 : 배열기반 구현 리스트
- 연결리스트 : 메모리의 동적 할당을 기반으로 구현된 리스트

기능은 똑같다.
둘의 차이는 구현 방법에 있다

리스트의 특성
> 데이터를 나란히 저장한다 중복이된다 



# 리스트
> 리스트라는 자료구조는 데이터를 저장하기 위한 자료구조 

선형까지는 이렇지만 비선형가면 바뀐다 

데이터의 관리가 목적인 자료구조는 맞긴하다 

헤더파일 
```c
#pragma once
#ifndef __ARRAY_LIST_H
#define __ARRAY_LIST_H
#define TRUE 1
#define FALSE 0

#define LIST_LEN 100
typedef int LData; // 다양한 자료형들을 수용위해서

typedef struct __ArrayList {
	LData arr[LIST_LEN];
	int numOfData;
	int curPosition;
} ArrayList;

typedef ArrayList List;

void ListInit(List* plist);
void LInsert(List* plist, LData data);

int LFirst(List* plist, LData* pdata);
int LNext(List* plist, LData* pdata);

LData LRemove(List* plist);
int LCount(List* plist);

#endif
```

리스트 내부 동작 구현 
```c
#include <stdio.h>
#include "ArrayList.h"

//초기화할 리슽의 주소값을 인자로 전달
//리스트 생성후 제일 먼저 호출되어야 하는 함수
void ListInit(List* plist) {
	(plist->numOfData) = 0;
	(plist->curPosition) = -1;
}
//리스트에 데이터 저장한다,매개변수 data에 전달된 값 저장 
void LInsert(List* plist, LData data) {
	if (plist->numOfData > LIST_LEN) {
		puts("저장이 불가능 합니다");
		return;
	}
	(plist->arr[plist->numOfData]) = data;
	(plist->numOfData++);

}

int LFirst(List* plist, LData* pdata) {
	if (plist->numOfData ==0) {
		return FALSE;
	}
	*pdata = plist->arr[0];
	plist->curPosition = 0;
	return TRUE;

}

int LNext(List* plist, LData* pdata) {
	if (plist->curPosition >= (plist->numOfData)-1) {
		return FALSE;
	}
	plist->curPosition++;
	*pdata = plist->arr[plist->curPosition];
	return TRUE;
}
// 삭제하는 대신에 한칸씩 앞으로 떙겨야한다 
LData LRemove(List* plist) {
	LData temp = plist->arr[plist->curPosition]; // 삭제할 데이터 저장 
	int num = plist->curPosition;
	for (int i = num; i < plist->numOfData-1; i++) {
		plist->arr[i] = plist->arr[i + 1];
	}
	plist->numOfData--;
	plist->curPosition--;
	return temp;
}
int LCount(List* plist) {
	return plist->numOfData;
}

int main(void) {
	return 0;
}
```

# 배열 기반 리스트 
순차리스트라고한다

단점
- 배열의 길이가 초기에 결정되어 변경이 불가능하다
- 삭제의 과정에서 데이터의 이동(복사가) 매우 빈번히 일어난다

장점
- 데이터의 참조가 쉽다. 인덱스 값을 기준으로 어디든 한 번에 참조 가능 
