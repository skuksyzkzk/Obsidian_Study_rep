![[0x01-SecurityPrinciples(Extended).pdf]]


## 6 
크롬브라우저의 사용 이유중 하나가 플러그인 
플러그인 하나 당 프로세스 하나라 메모리가 많이 먹는다

## Cache side - Channel Attacks 
## Flush and Reload Attack
최근에는 cloud에 ai workload가 많다 보니 ai model을 그대로 카피하기도 한다 

cpu 하드웨어 적인 부분은 패치가 쉽지않다 
소프트웨어적으로 만 조금 할 뿐 

> [!e] melt down
> 공격 핵심이 Flush and Reload Attack 
> kernel이 어떤 메모리를 건드렸는지 긁어 내서 kernel의 메모리를 읽어 낼 수 있다.
> 그렇게 되면 kernel이 관리하는 암호화키나 이런것이 빠져 나갈 수 있다
> 결국 해결 못해서 
> 메모리 관리 하는 방법을 바꾸는 것으로 했다.
> 시스템 콜 성능 25프로 감소했음



## 8 .Psychological Acceptability Principle

보안 메커니즘이 리소스 사용하는 데 있어서 방해주면 안된다.

예전의 공인인증서 USB

보안도 human factor 많다 개발자 입장에선 좋지만 User입장에선 ...

모든 운영체제 하나하나씩 allow하라고 알려주고 하는 것은 너무 sensitive하게 하는 것도 안좋다

### HCI(human computer interaction)

### 메타버스

통계적 특성을 이용해서 사람 특정 가능하다 

메타버스 내의 통계적 특성을 없애서 나인지 모르게한다

## 9 . Defense in Depth
보안 기술이 겹겹이 쌓인 계층을 이루어서 존재해야한다
한 가지가 막지 못해도 다른 계층이 기다리고 있는 구조

> [!d] chrome browser
> single points of failure를 만들지 말자
> 
> 
> 

> [!e] User Authentication
> 1. Password 컨트롤 
> 	1.  유저를 컨트롤하기 힘들고 패스워드는 랜덤값이 아님 취약 
> 2. Anomaly Detection
> 	1. 해외 로그인
> 3. Two-Factor Authentication
> 	1. 인증앱으로 인증해야 로그인되는 그런 것들
> 	2. Gmail
> 	3. 바이낸스 이메일 인증 로그인할때 

# Case Study

> [!c] Case study 
> conflict 날 수도 동시에 적용 가능 할 수도

OpenSSH server 
- 서버의 shell을 내 노트북에서 편하게 사용 가능 하게 해준다
서버에 내가 보낸 코드조각을 실행시켜서 공격 
이럴 경우 루트권한을 얻어서 시스템이 한번에 넘어 갈 수도있다

루프는 당연하게 해야 되는 것 

OpenSSH 개발자의 결정(어떻게 해결하지)
> Privilege Separation을 해야겠다

하나의 프로그램을 여러개 프로세스로 나눔
네트워크 쪽이 터져도 패스워드나 다른 파트 영향 안가게 separately하게 설계

71
최근에는 sandbox 처럼 메모리 공간을 다르게 세팅해서 다른 프로세스한테 영향 안가게 설계 

seccomp는 네트워크 안쓴다 하면 네트워크 쓰는 시스템콜 금지시켜버리는 게 가능

- 시스템콜 허용 금지 관리

> IPC

개발하기가 어렵다

프로세스로 나누면 오버헤드가 크니까 
쓰레드로 나눠서 isloation하자는게 최근에도 나오고 있다

### Trusted Execution Environments (TEE)

격리된 구간을 만든다
아무것도 믿지 않고 내가 신뢰하는 특정 코드만 격리해서 그것만 믿자

- separation priviliege

하드웨어에 들어갈려면 검증만 몇년 이상 걸림 
하드웨어 건들이면 컴파일러바뀌고 나머지 sdk도 바뀌고 

ai inference 가벼운건 이미 arm cpu에 들어가기 시작함
격리해서 실행하는 TEE는 이미 많이 적용된다

어디에 쓸까?

>[!e] 삼성페이 넷플릭스
>안드로이드 운영체제도 못본다 격리되어 있음 
>DRM(digital rights management)
>- 4k를 유저에게 쏠려면 격리가 되어있어야 가능
>- 화면에 나오게 될려면 격리되어있다가 나옴 
>클라우드에서 ai돌릴때 데이터 노출하고싶지 않아서 


### Monolithic Kernel vs MicroKernel

Mono
- 한 덩어리 우리가 쓰는 
- 권한 분리가 안된다
- 파일시스템에 문제있으면 다 영향

Micro 
- 이론적으로는 존재 우리는 잘 안씀
- 중요한 부분만 kernel에 넣어두고 나머지는 least privilege로 가서하자
- 

항상 principle이 우선이 아니라 융통성이 있어야 된다

Microkernel security model
- 이상적으로는 mono보다 더 안전하고 robust  한 것은 맞다
- separation of privilege

Monolithic kernel security
- single-point-of-failure 존재 할 수 있다
- 공격자가 취약점을 하나만 찿으면 full system권한으로 변경가능 

그럼에도 우린 monolithic한 것을 사용 
> micro kernel에 비해 구현이 쉽다 간단하고 빠르고 이게 큰 장점 


# Discussion
이런 것들이 적용된 사례 ?
- 