![[0x01-SecurityPrinciples(Extended).pdf]]


## 6 
크롬브라우저의 사용 이유중 하나가 플러그인 
플러그인 하나 당 프로세스 하나라 메모리가 많이 먹는다

## Cache side - Channel Attacks 
## Flush and Reload Attack
최근에는 cloud에 ai workload가 많다 보니 ai model을 그대로 카피하기도 한다 

cpu 하드웨어 적인 부분은 패치가 쉽지않다 
소프트웨어적으로 만 조금 할 뿐 

> [!e] melt down
> 인텔에서 발견된 melt down 취약점 
> 유저와 커널은 분리되어야 하는데 유저에 있는 프로세스가 커널 메모리를 읽을 수 있게 해준 버그 
> 공격 핵심이 Flush and Reload Attack 
> kernel이 어떤 메모리를 건드렸는지 긁어 내서 kernel의 메모리를 읽어 낼 수 있다.
> 그렇게 되면 kernel이 관리하는 암호화키나 이런것이 빠져 나갈 수 있다
> 결국 해결 못해서 
> 메모리 매핑 하는 방법을 바꾸는 것으로 했다.
> 시스템 콜 성능 25프로 감소했음



## 8 .Psychological Acceptability Principle

보안 메커니즘이 리소스 사용하는 데 있어서 방해주면 안된다.

예전의 공인인증서 USB

보안도 human factor 많다 개발자 입장에선 좋지만 User입장에선 ...
사람을 짜증나게 하면 잘 안쓰게 된다.
모든 운영체제 하나하나씩 allow하라고 알려주고 하는 것은 너무 sensitive하게 하는 것도 안좋다

### HCI(human computer interaction)
ui 디자인 할때 커서를 얼마 크기로해야 클릭이 잘될까 이런거 


### 메타버스
팔길이 머리크기 이런 개인적 특성이 통계적 특성으로 구분 가능하게 한다
통계적 특성을 이용해서 사람 특정 가능하다 

메타버스 내의 통계적 특성을 없애서 나인지 모르게한다

## 9 . Defense in Depth
보안 기술이 겹겹이 쌓인 계층을 이루어서 존재해야한다
한 가지가 막지 못해도 다른 계층이 기다리고 있는 구조

> [!d] chrome browser
> single points of failure를 만들지 말자
> 
> 
> 

> [!e] User Authentication
> 1. Password 컨트롤 
> 	1.  유저를 컨트롤하기 힘들고 패스워드는 랜덤값이 아님 취약 
> 	2.  패스워드는 사람이 만드는 것이니까 그래서 특수문자 있어야된다 이런게 요즘 도입되는 거 
> 2. Anomaly Detection
> 	1. 해외 로그인
> 3. Two-Factor Authentication
> 	1. 인증앱으로 인증해야 로그인되는 그런 것들
> 	2. Gmail
> 	3. 바이낸스 이메일 인증 로그인할때 

# Case Study

> [!c] Case study 
> conflict 날 수도 동시에 적용 가능 할 수도

OpenSSH server 
- 서버의 shell을 내 노트북에서 편하게 사용 가능 하게 해준다


서버에 내가 보낸 코드조각을 실행시켜서 공격 
이럴 경우 루트권한을 얻어서 시스템이 한번에 넘어 갈 수도있다

루프는 당연하게 해야 되는 것 

OpenSSH 개발자의 결정(어떻게 해결하지)

> Privilege Separation을 해야겠다

하나의 프로그램을 여러개 프로세스로 나눔
네트워크 쪽이 터져도 패스워드나 다른 파트 영향 안가게 separately하게 설계

71
Process isolation

> [!d] chatgpt 해석 
> 프로세스 수준의 격리는 여러 프로세스가 각자 독립된 주소 공간을 가지고 있는 것을 의미합니다. 이는 메모리 오류가 자연스럽게 해당 프로세스 내부로 제한되는 것을 의미합니다. 즉, 한 프로세스에서 발생한 메모리 오류는 다른 프로세스에 영향을 미치지 않습니다.
또한, 각각의 프로세스는 다른 사용자 권한으로 실행될 수 있습니다. 예를 들어, root(uid=0), someuser1(uid=56), someuser2(uid=120) 등 다양한 사용자 권한으로 프로세스를 실행할 수 있습니다. 이는 보안을 강화하고, 각 프로세스가 실행하는 작업에 대한 제어를 갖게 합니다.
또한, 각 프로세스는 다양한 샌드박스 설정으로 실행될 수 있습니다. 이러한 설정은 seccomp, SELINUX 규칙 등을 포함할 수 있으며, 프로세스가 실행될 때 특정한 규칙에 따라 행동하도록 지정할 수 있습니다. 이를 통해 프로세스가 더욱 안전하게 실행되고, 악의적인 활동으로부터 시스템을 보호할 수 있습니다.

최근에는 sandbox 처럼 메모리 공간을 다르게 세팅해서 다른 프로세스한테 영향 안가게 설계 

> [!c] Sandbox
> 프로세스나 애플리케이션을 격리된 환경에서 실행하도록 구성하는 보안 기술을 가리킵니다. 이러한 설정은 시스템 내에서 실행되는 프로세스의 활동을 제한하고, 시스템 자원에 대한 액세스를 제어하여 보안을 강화합니다.

Sandbox설정을 구현하는 방법이 seccomp


seccomp는 네트워크 안쓴다 하면 네트워크 쓰는 시스템콜 금지시켜버리는 게 가능

한 프로그램에 한 컴포넌트를 넣는 sandbox처럼 사용한다는 것 
- 시스템콜 허용 금지 관리

> IPC
> 	두개의 프로세스가 있으면 서로 통신하게 하는 것
> 	이게 가장 큰 오버헤드 이다  

개발하기가 어렵다

프로세스로 나누면 오버헤드가 크니까 
쓰레드로 나눠서 isloation하자는게 최근에도 나오고 있다

### Trusted Execution Environments (TEE)

격리된 구간을 만든다
아무것도 믿지 않고 내가 신뢰하는 특정 코드만 격리해서 그것만 믿자

- separation priviliege

하드웨어에 들어갈려면 검증만 몇년 이상 걸림 
하드웨어 건들이면 컴파일러바뀌고 나머지 sdk도 바뀌고 

ai inference 가벼운건 이미 arm cpu에 들어가기 시작함
격리해서 실행하는 TEE는 이미 많이 적용된다

어디에 쓸까?

>[!e] 삼성페이 넷플릭스
>안드로이드 운영체제도 못본다 격리되어 있음 
>
>DRM(digital rights management)
>- 4k를 유저에게 쏠려면 격리가 되어있어야 가능
>- 화면에 나오게 될려면 격리되어있다가 나옴 
>클라우드에서 ai돌릴때 데이터 노출하고싶지 않아서 

삼성페이 
```
삼성페이에서 Trusted Execution Environment (TEE)는 중요한 보안 기술로 사용됩니다. TEE는 안전한 환경에서 실행되며, 주로 안전한 데이터 저장, 인증, 암호화와 같은 보안 기능을 제공합니다. 삼성페이에서 TEE는 다음과 같은 목적으로 사용됩니다:

1. 보안 요소의 분리: TEE는 안전한 환경을 제공하여 중요한 작업들이 안전하게 수행될 수 있도록 합니다. 예를 들어, 사용자의 신용카드 정보나 인증서 등의 중요한 정보는 TEE 내부에서 안전하게 관리되고 처리됩니다.
    
2. 결제 정보 보호: 삼성페이는 사용자의 결제 정보를 안전하게 보호해야 합니다. TEE를 사용하면 이러한 정보들이 암호화되고 안전한 곳에 저장되므로, 해킹이나 악의적인 공격으로부터 보호됩니다.
    
3. 안전한 통신: TEE를 사용하여 삼성페이 애플리케이션과 결제 시스템 간의 통신이 보안되고 안전하게 이루어집니다. 이를 통해 중간자 공격과 같은 보안 위협으로부터 보호됩니다.
    

요약하자면, 삼성페이에서 TEE는 사용자의 결제 정보를 보호하고 안전한 환경에서 결제 작업을 수행함으로써 보안을 강화하는 데 사용됩니다.
```
### Monolithic Kernel vs MicroKernel

Mono
- 한 덩어리 우리가 쓰는 
- 권한 분리가 안된다
- 파일시스템에 문제있으면 다 영향

Micro 
- 이론적으로는 존재 우리는 잘 안씀
- 중요한 부분만 kernel에 넣어두고 나머지는 least privilege로 가서하자
- 

항상 principle이 우선이 아니라 융통성이 있어야 된다

Microkernel security model
- 이상적으로는 mono보다 더 안전하고 robust  한 것은 맞다
- separation of privilege

Monolithic kernel security
- single-point-of-failure 존재 할 수 있다
- 공격자가 취약점을 하나만 찿으면 full system권한으로 변경가능 

그럼에도 우린 monolithic한 것을 사용 
> micro kernel에 비해 구현이 쉽다 간단하고 빠르고 이게 큰 장점 


# Discussion
이런 것들이 적용된 사례 ?


![[0x02-AccessControl.pdf]]

# Authentication

> 내가 누군지를 증명하는 과정

사람이 기억해야만 되는 부분이 취약점

여러가지로 pw가 가장 authentication problem에서 문제 야기

- pw가 간편하고 사용하기 쉽기에 대부분 authentication하는 방법임 관리하기도 편함
- 구글은 따로 키가 있는데 그건 관리가 힘듬 
- biological한 부분은 잃어 버리거나 이런 건 상관안써도 ㄱㅊ
- 하지만 대규모 서비스에 투입하긴힘듬

Crypto key 
- 이것도 최근에 RSA키 들은 양자컴퓨터 공격에 취약
PW

one password 

실제 서비스들은 패스워드는 해싱을 떠서 그걸 저장 
hash = one way encryption function
수학적으로 역함수 찿는게 불가능
공격자는 forward search밖에 할수가없다

파일 해시값으로 integrity알수있는 것처럼 그걸 PW에 적용

좋은 CHF기준
1. 인풋사이즈 노상관
2. 사이즈는 고정된 결과값
3. 계산 빨라야된다

안정성에 대한 요구 

1. onewayness guarantee


### weak Resistance 조건

해시와 알고리즘을 아는 경우
공격자가 x라는 hash값을 알경우
같은 hash값을 내는 인풋값을 찿기 어려워야된다
무한대가 아니기에 collision발생 가능성

SHA256이런것들은 이미 검증

### strong resistance
공격자가 hash알고리즘을 알고있을때 
input pair 일치하는 hash값 못찿

## Bruteforcing
> 될때까지 머리박기

login 
 - 횟수제한 몇번이상틀리면 계정 잠김 
 - 
hash 
- hash값을 확보해서 내컴퓨터에서 돌림

매일 쓰는 알고리즘은 computation power가 충분해도
reasonable한 시간으로 안풀리는 것들

#### Dictionary attack
좀 더 확률 높이는 법

