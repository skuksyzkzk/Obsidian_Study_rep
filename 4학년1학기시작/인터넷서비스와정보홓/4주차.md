
![[0x05-Crypto-and-TLS.pdf]]

# Problem of thousands of years

confidentiality 
- 잡히거나 그러면 큰일
integrity
- 내 메시지가 변조될 가능성
- 도난 당해서 수정되어있어 있을 수도 있다
Authenticity
 - 왕으로 부터 온게 맞나

이 3가지 문제를 해결하기 위한 것이 *Crpyto*


## 예전 
나무로 만든 바톤을 전달

key가 그 바톤그 자체 나무와 종이길이 자체가 키로 적용
- 당연히 안전하지 않다 

16pg 

암호화 되기 이전의 text = plaintext
key is secret

대칭키 암호 

# Crypto

키를 제외한 모든 요소를 공개한다
크립토 알고리즘은 대부분 공개되어있다

> kerckhoff's principle 
> 난해함을 통한 보안은 별로 효과적이지 않다 
> 오히려 시스템이 공개되어있어도 안전해야한다



# 고대의 cyper

## Caesar's cipher
key permutation 을 통해서 가능성 = 애니그마 처럼 
하지만 2^88 key여도 굳이 다른 방법써도된다

24pg
빈도분석 

알파벳 e는 빈도수가 높다 
이러한 빈도의 차이 라는 특성을 이용해서 하면 bruteforce경우의수줄인다

26
F가 빈도수가 많으니 e로 치환해보자

> 이 방식은 안전하지 않은 대표적인 방법 

*크립토 시스템에서 안전한 방법은 BruteForcing만이 유일한 방법인 것이 안전한 시스템*


## One time pad 
plaintext랑 key랑 xor 연산

이름이 one time pad 이니까 key를 한번만 쓰고 버려야된다
키가 1번만 쓰인다는 가정하에 이론적으론 굉장히 안정적 

가정 
- pad 는 랜덤해야하고 항상 항번만 사용
- pad는 sender하고 receiver에게 즉 두명에게만 전달되어야한다

key가 메시지 크기만큼 같다
사이즈가 너무 커질수도 있다
> stream cyper
## Codebook cipher

미리 특정 단어나 시퀀스를 기록하는 코드들을 기록하고 교환 
둘 다 코드북을 가지고 있으면 안전하게 통신 가능
> block cipher

Additive한 성격이 있다 
코드를 더하고 뺴서 동작도 한다

키가 주어지면 랜덤 컨벌트하는 코드북생성

### Stream cipher vs block cipher

스트림 사이퍼는 구현하기 편하다 
블록 사이퍼는 항상 블록으로 구현하도록 되어있어서 nbit씩 끊어 연산
데이터가 많을 수록 ~ 인터넷같이 출력량이 많은 것 에서 쓰인다


## one more thing: randomness
과연 랜덤이란 것이 우주에 존재할까?

시벌 다음문제에 대한 힌트

42 

크립투 구현에선 randomness 가 중요 

### RNG
게임에서 주로 사용

아이템 뽑기 갓차
확률성 아이템

---

대부분 컴퓨터에 RNG 있다

TRNG는 physical randomness에 기반 회로에 흐르는 전기 이런것들 기반

PRNG는 우리가 주로 사용하는 것
- 사람이 seed값을 주면 seed값을 통하여 
- 근데 사람이 시드값을 준다는게 문제 

47

암호학적으로 안전한 PRNG
교수님도 잘 모른다함

## symmetric-key 
같은 키를 암호화 복호화에 모두 사용하는 시스템 
대부분 인터넷 메세지가 이렇게 암호화된다

DES 많이 쓰인다
- Block cipher 
	- 스트림 사이퍼로서 쓰일수 있긴한다
	- block size 64
	- key 56bit
- 요즘엔 안쓴다
	- aes256/128많이 쓴다 
- 예전엔 많이 쓴것 30년 동안 
- 3DES도 나오긴했다 키를 3개쓰는 방식 
- 현재는 AES

AES
- 똑같이 block cipher사용
- AES 256
- gold standard다 요즘 
- 여러가지 크립토 시스템은 클라이언트와 서버가 서로 정해야된다
- 근데 그게 256많이 쓴다
- 많이 쓰다보니 하드웨어 가속도 되어서 더 많이 사용하는 추세 -ARM,intel 

block cipher알고리즘 자체는 한 블록을 어떻게 알고리즘화할까에 초점 
현재 사용되는 것은 GCM

57
각 블록 암호화시 어떤 방식 선택해야하나 
Confientiality에 이어 integrity와 auth를 추가

### ECB
안쓴다
각 블록을 동일한 파라메터로 encryption한다
같은 plaintext는 같은 cipher text로 나온다

CTR : 숫자를 계속 increment하면서 각 구역을 붙여서 암호화 

## GCM
c = counter

diversification이 들어가서 같은 plaintext라도 다른 ciphertext

plaintext에 대하여 mac을 계산 
- authentication보장
	- sender를 인증할수가있나 sha값을 가지고?

chacha20

구글이 만듬 
AES는 노트북 CHACHA iot나 스마트폰에선 더 빠르다 
TLS 1.1에서는 서버와 클라이언트가 서로 알고리즘을 그걸 쓰는데 목록보고 


## hash func 
- 해쉬는 one way 
symmetric key와 원리는 비슷 
- 키가 없다 그래서 computation이 빠르다 

임의의 데이터에 대해 fingerprint만듬
파일 다운로드 그런거 검사하는 integrity검사 

#### MAC
Message Authentication Code

- one way Func 
- 메세지에 대한 hash값을 만든다
- integrity담당 - hash
- 키가 들어가는 one way
- Mac은 integrity authentication동시보장

*mac은 키가 사용되지만 hash는 키가 사용되지않는다 *


### GCM에는 MAC이 들어가 있다 



![[QnA-Mar-26.pdf]]
