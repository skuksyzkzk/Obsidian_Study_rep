![[0x01-SecurityPrinciples.pdf]]


# CIA 

## confidentiality (기밀성)

데이터를 안전하게 보관/보안을 떠올리면 대표적으로 떠올려지는 이미지 

정보에 대한 control 

권한 있는 자에게만 접근 가능한 것 

confidentiality와 암호화는 과거부터 이어져 옴 

세계 2차 대전에서 발전 /독일이 쓴 기계 = ENIGMA 

> 알파벳을 다른 알파벳으로 치환하는 아이디어 기반 

날마다 기계의 세팅을 매번 바꾸었다.

Machine setting => Key값으로 세팅 key값을 매번 바꾼 것 

24시간 안에 많은 경우 대입이 힘들어서 실패 

hint 1 . 같은 알파벳으로 치환안한다
hint 2. 특정 단어들이 특정 위치 
	특정 시간에 특정포맷 ( 항상 날씨 예보)
	특정 위치에 올 것을 예측 
### known-plaintext attack 
>plaintext = 원본 문서 
>cipher text = 암호화된 문서

다른 것을 모르지만 이건 어떤 plaintext라고 유추할수있는 것 

## intergrity

confidentiality는 남이 봐도 몰라야된다

무결성 ( 남이 망칠수있으면 안된다)

허가받지 않은 사용자가 특정 정보에 대해 수정및 삭제가 불가능한것 

만약에 수정되거나 삭제되면 무결성이 깨진것 

과거에는 seal로 보장 

today 
현대에선 hash fucntion이 역할하고있다

알려진 hash function을 같은 값을 넣어서 결과값 확인으로 파일 변조 확인 

## confidentiality & integrity

https 
> tls라는 보안프로토콜에 의해서 성립 모두 2가지 보장
> packet이 구글서버로 가려면 첫번째로 와이파이 라우터 -> 학교망 ->kt -> 서버 
> 위험하다 누구든 가로챌수있음
> 하지만 https가 보장 

## Avaliability (가용성)

항상 사용 가능해야 한다

> 가용성을 해치는 공격 => 디도스

### DDos
심지어 분업화 되어있음 감염 시키고 관리하고 파는 사람 따로 

## Not - repudiation (부인방지)
증거를 남기는 행위 어떤 동작에 대해

예) Digital Signature 
	TimeStamps

### CA
키를 보장해주는 권위있는 단체 

주민등록증이 의미있는 건 정부가 인증해주기 때문 

## Authentication

정체를 검증하는 행위 
너가 정말 너가 말한 너가 맞느냐
예)로그인

- github- public key를 등록해야 된다

### Access control
기존의 리눅스 ACL

MAC -> 중앙집권적인 Access control

RBAC -> 교수,학생,조교 각 rule마다 접근할수있는 resource가 달라짐 


## Attestation (공증)

app의 integrity를 검증해주는 과정 보증해주는 개념 

# Security design principles 

1. least privilege 최소권한
	1. 특정 Access에 대해선 정말 필요한 사람만 권한 가져야된다
	>사용자나 프로세스한테 최소한의 권한만 부여한다
	>불필요하게 너무 권한이 많아져서 공격자가 시스템접근하는거 막기위함
	1. Chrome Browser-현대 보안 기술 집약체 
2. Fail-safe Defaults Principle 실패 안전 기본값 
	1. 명시적 권환이 없으면 Access Denied 되야한다 그래서 시스템이 실패해도 안전한 상태여야된다
	2. 1번이 기본 설계가 되어야 한다
	3. Mobile- 권한 전부 부여해야한다 앱마다 
	4. **CVE** 보고된 모든 취약점이 기록되어있다
	5. 패치 대부분 언급되어있다
	6. 취약점에 부여된 유니크한 넘버
3.  Economy of Mechanism Principle
	1. 심플해야 함 security mechanism은 간단해야된다 
4. Complete Mediation principle 완전한 중재 
	1. 모든obj에 대한 접근은  매번 체크 되어야한다
	2. 운영체제에서 system call 32pg
	3. syscall을 실제로 쓸 일은 없다 그 정도로 row하게는 안감 
	4. 뭘하는 결국 운영체제를 거친다 34 
5. Open Design principle 
	1. 보안 메커니즘은 그것의 구현이나 설계에 의지해선 안된다 
	2. 나만의 방식으로 복잡하고 모호하게 하는 것보다는 알려진 알고리즘으로 사용해도 안전해야한다
	3. 화분밑 열쇠 
6. Separation of privilege principle
	1. 한 가지 조건으로 허가 하지 말자
	2. (단일 조건 기반으로 권한을 부여해서는 안된다)
	3. Single - point - of - failiure 만들지 말자 
	4. least privilege 랑 비슷하다 첫번째 룰과
	5. 실제 민주국가에선 power를 seperation 함 
	6. Chrome browser가 정부처럼 access 컨트롤 기능 다가지고있다 
	7. One process per plugin
	8. 42pg 단점:  성능 저하 ( 메모리 많이 먹는 다)
	9. 웹브라우저가 가장 민감하다 보안에 
	10. 우린 매번 js를 돌린다 서버로 부터 
7. Least Common Mechanism Principle
	1. sharing을 많이 할수록 위험하다 
	2. 서로 다른 서비스가 하나의 체제 위해서 돌아가는데 쉐어링을 할수록 서로에게 영향이 간다
	3. 48pg 열로서 
	4. 52pg cache 한번 접근한건 그뒤로 빠르게 처음은 느리다
		1. 이 두개 시간 비교가 가능하다 시간의 차이 
		2. 접근 했던 메모리의 온도 만으로도 유추 가능 
		3. 48pg처럼 뜨거운 전구 처럼 
		4. 그게 Flush and Reload Attack 
	5. # 여기까지 


