
![[0x03-AccessControl.pdf]]

# Access control

Authentication과 authorization 

## Complete mediation
모든 메모리 접근에 대해 cpu가 관리 
쓰면 안되는 메모리 쓰면 seg falut 뜬다

Hw접근에 대해 kernel이 권한

User와 kernel 권한이 나눠진 seperation 그 조건도 만족 

# Policy Model
> [!d] Goal
> 허가되지 않는 정보공개를 막는다 
> 정보의 흐름을 컨트롤한다  
> 
> 


1. Confidentiality 
	1. 초기 컴퓨터 엑세스 컨트롤은 군대에서 나옴 
	2. MLS가 초기 (multilevel security)
		1. 가장 기초적인 이론의 토대가 BLP
		2. 정보에 label을 붙이고 유저에게도 각 등급별 권한 부여한다
		3. 이런 방식이 MLS인것 주목적은 information flow를 막기위함
		4. unauthorizational reading 막는게 목적 
		5. clearance가 어느 단계 까지 접근가능한지
		6. *only Read Down, Writes Up*
		7. No write Down 
			1. 대통령이 중요하지 않는 단계에 write down되면 정보가 셀수가 있다 
			2. 실수로 할수있기에 
		8. MLS 방식 중에서 최근 사용
			1. DAC (discretionary)
				1. object의 접근을 사용자(문서의 주인)에게 전부 맏긴다 
				2. 아이캠퍼스는 그러나 DAC 아니라 MAC
				3. *운영체제가 DAC* 
				4. Object owner에게 접근권한 다준다 
				5. chmod 777 myfile 
						1.유저 그룹 모두에게 권한 부여
			1. 중앙통제방식이 MAC 
				1. 내가 object owner여도 안된다
				2. 군,icampus
			2. Role-based access control(RBAC)
				1. icampus도 RBAC의 일종 
				2. 이런 형태의 시스템을 쓰는 게 대기업 내부 시스템 관리 할때 디자인 팀이 접근,엔지니어팀이 접근 가능하는 것들이 다르다 
				3. Role에 따라서 접근 다르게 
					1. least privilege

# Access control implementation approaches 

## Access control Matrix 
가로 세로에 따라 

ACL 
- 누가 오브젝트에 접근가능한가 
- group permission 
- store access control matrix by **COL**

Capabilities 
- 이건 위조불가능한 토큰을 유저가 들고있는 것 
- Central access controler 가 유저의 토큰이 valild한지 허가가 나있는지를 확인한다 
- 원래 파일에 달려있는 데 이건 유저가 뭘 접근할수있느냐 방식으로 동작 
- unix,linux는 확실히 acl 
- store access control matrix by **Row**

ACL 은 오브젝트 위주 파일에 대해서 걸려있다
Capability는 유저에게 걸림 

ACL은 주최측이 가지고있는 입장명단
Capability 방식은 ticket -> 편하다,탈중앙화

acl이 구현은 쉽다 
우리가 쓰는 대부분 시스템은 acl 
최근에는 capability가 더 좋은 접근이라고 하는 중(구글)

# 다음 챌린지가 confused deputy 





![[Tutorial Exploit Writing - 1. Automation.pdf]]

u 붙이는 이유 
- 서버 시스템이랑 연동되는데 리눅스에서 숫자로 시작하는 유저아이디 못만들어서 

# Reversing
리버싱을 도와주는 툴을 다운 받아야된다 
IDA Pro - 현업에서 가장 많이씀 무료버전 잘 안씀 
	-우리가 쓰기엔 ? 비싸다
Ghidra 

리버싱 툴이 잘되어있음 

GDB
- 플러그인 써면 비주얼화 잘되어있다 

파이썬으로 Scripting해야된다
프로그램이 취약점이 가진 state로 가기 위해선 자동화 필요 

파일을 받을때 취약점이 터지면 
로그인이런 것들을 자동으로 진행시키는 것 

악성 인풋을 전달해서 overflow일으키거나 공격 
ROP가 뭘까 

pwntool 이거 쓰면 된다 


1. 어떤 취약점 있나 분석 
2. 어떻게 공격점까지 가는 지를 스크립트로 구현 

print_flag라는 심볼을 실제로 읽어서 주소 저장 

process시발 

remote로 연결하는 건 실제로 풀때 
서버에 접속을해서 풀어야하니까 


gdb를 차일드 프로세스에 어태치 하고 
GDB 명령어를 자동으로 실행되게 스크립트로만드는 
568이 return 주소였다....

recvline()해서 한줄받고 send로 yes 보내서 자동화 

정규표현식으로 라인을 

Cyclic 저런 패턴을 만드는 이유 디버깅해야될때 실제 stack을 볼때
알아 볼수있는 패턴을 만드는 것 

그냥 stack 덮어쓰는 것 

코드 icampus에 올려서 템플핏으로 사용 
exploit writing은 복잡하지않다 이정도만  있으면 된다 .

# x86 리눅스 마련 
티먹스??pwn 파이썬 라이브러리 필요 


![[0x03-AccessControl-Extended.pdf]]

capability는 탈중앙화 

파일엑세스 할때마다 complete 중재자 

권한을 나누는 것 seperate pr

# confused deputy 

BILL : 중요한 파일 
컴파일러가 write 가능 bill
저 x 가뭐임 실행가능

alice는 컴파일러는 사용 가능
bill은 못건들인다 

confused deputy 
> 컴파일러를 실행시키는 동안 bill을 overwrite하는 권한 일시적으로 생긴다

컴파일러가 대리인(보안관)이 된다

컴파일러가 혼동된다(내부 시스템설계 실수)

컴파일러의 권한이 앨리스에 의하여 센다 


Capability를 통해서 구현한다면 어떻게 막을까 
> 앨리스가 자신의 토큰을 가지고 있으면 그걸로 확인하면 에초에 허가 없는게 보이니까 막는거 *사실이게 그냥 capabiliry*

전체적으로 시작한 사람의 토큰을가지고한다고 


> [!w] 왜 ACLs 취약한 것일까?? 
> 

## capability 
장점 delegation

단점 
- 느리다
- 운영측면에서 힘듬
	- 탈취가되면 문제 
	- 높은 권한이 실수로 낮은권한에게 티켓주면 ㅜㅜ 
	- 교수님이 아이캠퍼스관련 학생에게 토큰 줬는데 수강철회하면 그 토큰을 다시 철회해야된다 이런 관리 측면 
- 너무 보안에 대한 고려가 많닿
- 구현함에 있어서 어렵다

## SETUID

### etc/shadow 
> 여기에 모든 유저의 비밀번호가 해싱 되어 저장된다
> 모든 로그인 패스워드 프로그램은 shadow에 접근해야한다 

salt 를 pw와 결합해서 해싱 해서 저장 

62pg

문제점??

- 시스템프로그램이 읽어야된다
- 모두에게 열어주면 안전하지 않다 
	- 하지만 유저는 자기 자신의 pw는  바꿔야된다 
	- MAC mandatory 관리자 

해결 64 
- 특정 프로그램을 돌릴때는 오너의 권한을 빌릴수 있게한다 
	- 이게 setuid
- s토큰은 setuid가 걸려있는 프로그램을 나타내는 플래그 

Daemons 

RUID 
- 앨리스
EUID
- 루트
setuid걸려있으면 ruid하고 euid 다름
일반적으론 둘이 같아야되는데 

> [!e] EUID vs RUID
> RUID 는 프로세스를 시작한 실제 사용자의 ID 
> EUID는 프로세스가 현재 사용한 권한 ID
> 그래서 setuid가 걸려있는 프로그램에선 두개가 다를수있는거다 
> 예를 들어 이번에 confused deputy 공격 때는 RUID가 나고 EUID가 그 confused deputy 파일이다 


id asd pw abb 
asd - abb

id passwd pw 

confused -deputy 파일 
passwd -sha256    


공격이 될만한것
1. user inputs 
2. system inputs 간접적으로
3. 환경변수

setuid와 confused deputy 결합시 파괴적이다 
pw파일을 오버라이트해서 내가 아는 pw로 바꾸기


# ctf 목표
flag 파일을 읽자 

권한은 challenger 

1차적으로 못읽는다
confused-deputy에 대해서 confused-deputy
특정값을 입력해서 읽도록 유도 


# case study 

FD 

프로세스를 도메인으로 나눈다 intra processs isoloated

pointer도 signing해서 특정영역에서만 사용가능하다

포인터변조하는 예제 
- 대부분 overflow 발생해서 retrun address 바꾸는 식이 95 

토큰 사이닝 
실제 arm에서도 return address 서명해서 저장하도록 바뀌었다
사이닝으로 포인터보안하도록 많이 바뀜 

##

middle ware 자바같은것 
page table 

page table 바꾸는 것 context swithcing ㅅㅂ 이게 기억안나네 

커널은 슈퍼바이저 페이지 안에서 위치하고이어서 
유저가 아무리해도 커널까지 안가게 되어있음

유저나 커널을 분리하거나 읽기만 데이터를 생성한다든지이런일들 대신 

프로세스간 어드레스 나누어지는것도 

malloc 할떄 페이지테이블 업데이트되야될거같은디 
어떻게 할까
- syscall 권한을 받아서 일시적 대행 

File system access ctrl 
- confused deputy 당연히 존재 

리닉스 수도  = setuid 

