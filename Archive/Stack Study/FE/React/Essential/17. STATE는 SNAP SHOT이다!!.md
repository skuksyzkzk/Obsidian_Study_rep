
## state값을 이전 state값을 이용해 변경시키는 경우 !!
# 바꾸려면 상태 업데이트 함수로 새로운 함수를 보내야 된다.

> setIsEditing(isEditing);

이게 아니라 

>setIsEditing(wasEditing => !wasEditing);

함수를 넘겨주게 되면 자동으로 리액트가 현재 업데이트된 상태를 호출하기 때문에 
그렇기에 기존의 
```jsx
setIsEditing(!isEditing);
setIsEditing(!isEditing);
```
이렇게 2번 하게 되면 기존이 false 였으면 true => false 이렇게 설정될거같지만 
실제로는 둘다 true true였던것 하지만 
함수로서 실행한다면 
>setIsEditing(wasEditing => !wasEditing);
>setIsEditing(wasEditing => !wasEditing);

이럴경우는 true -> false로 간다 왜냐면 현재의 업데이트시켜서 상태를 호출하기에 


# Snap shot 
생각하기에 내가 클릭 같은 이벤트를 실행하면 바로 인터페이스가 바뀔거를 예상한다 
하지만 리액트에서는 조금 다르다.
리액트에서는 인터페이스가 변화하려면 state가 업데이트 되어야한다.

## 랜더링이란
랜더링이란 리액트가 컴포넌트를 호출하는 것 

### ==When React re-renders a component:

1. React calls your function again.
2. Your function returns a new JSX snapshot.
3. React then updates the screen to match the snapshot your function returned.
![[Pasted image 20240124192344.png]]

```jsx
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button onClick={() => {
        setNumber(number + 1);
        setNumber(number + 1);
        setNumber(number + 1);
      }}>+3</button>
    </>
  )
}
```

버튼을 클릭하면 우리는 +3이 증가할것으로 기대하지만 
그러나  number는 클릭하면 1만 증가할 뿐이다 . 

왜냐고??

# state값을 세팅하는 것은 다음 랜더링 때만 바뀌기에 
중간에는 바뀌지 않는다 
number는 setNumber가 실행해도 0인 상태다 
진짜 snap shot으로 그 순간을 찍힌다음 시작하는것 
3라인의 setNumber에서 전부 number는 함수 시작전이 0으로 3군데 다 세팅되어있다.

```jsx
<button onClick={() => {
        setNumber(number + 5);
        alert(number);
      }}>+5</button>
```

여기서 alert하면 당연히 이제는 알겠지만 0이 나온다
중간에는 변하지 않기에 다음번에 눌러야지만 5가 나온다.