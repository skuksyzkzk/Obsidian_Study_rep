
### 타입스크립트는 정적타입의 컴파일 언어
- 코드 작성 단계에서 타입 오류 확인 
- 에러를 줄일 수 있음
- 타입스크립트는 자바스크립트로 변환 후 브라우저나 node js 환경에서 동작
- 자바스크립트의 슈퍼셋 
### 자바스크립트는 동적타입 런타임

# 타입 종류
```typescript
//문자

let str: string

let red: string = "REd" // 문자 단어만 할당 가능

let blue: string = `my color is ${red}`

//숫자

let num: number //최초 undefined 시작이지만 이후에는 숫자가 할당되어야 한다

//console.log(num) 이거 오류뜸 undefined 이고 아직 할당이 안되서 사용 못한다 사용할거면 할당 후 사용

let float: number = 3.14

let infinity: number = Infinity

let nan: number = NaN

//불린

let isBoolean: boolean

let isDone: boolean = false

  

//Null/undefined

let nul: null

let und: undefined

//console.log(nul) 이거 오류뜸 널을 초기화 안해서 nul은 그냥 null만 들어갈수있음 잘 안쓴다

  

///배열

//해당 타입만 들어가는 경우

const fruits: string[] = ["APple","bannna"]

const numbers: number[] = [1,2,3]

//섞이는 경우

const union: (string|number) [] = ['apple',1,2,'helo'] //union 타입

//const array: [] = [1,2,3] 이것도 안됨

  

// 객체타입

// 이렇게 이런 타입들도 오브젝트라서 실제론 저렇게 object라고 안씀

const obj: object = {}

const arr: object = []

const func: object = function () {}

// 실제로 쓰는 것

// 근데 이렇게 사용하면 조금 불편함 매번 타입을 작성해야되니까

const userA : {

    name: string

    age: number

    isValid: boolean

} = {

    name: "Halsy",

    age: 27,

    isValid: true

}

const userB : {

    name: string

    age: number

    isValid: boolean

} = {

    name: "Max",

    age: 27,

    isValid: true

}

//이래서 인터페이스를 사용한다. 시작을 대문자로

interface User {

    name: string

    age: number

    isValid: boolean

}

  

const userC: User = {

    name: "Maxxxxx",

    age: 27,

    isValid: true

}

  

/// 함수

// void는 return하는 것이 없으면 void를 붙인다

const hello: () => void = function () {

    console.log('Hello Worlds')

}

//이걸더 선호

const hello2 = function (): void {

    console.log('hi')

}

const h: void = hello()

  

const add: (x: number,y:number) => number = function (x,y) {

    return x+y

}

//이걸더 선호

const add2 = function (x:number,y:number) : number {

    return x+y

}

const a: number = add(1,2)

  
  

//Any

// 어떤 타입이든 가능하기에 사용하지 않는 것이 좋다,타입관리를 엄격하게 해야지 에러도 덜 발생하고 ts 쓰는 이유가 있는것

// js랑 똑같은 거니까

let h123: any = 'Hello world'

h123 = 123

h123 =[]

  

// Unknown

// 어떤 데이터가 할당될지 모르기에 알수없다

const a1: any = 123

const u: unknown = 123

  

// any는 다 가능해버림 이렇게

const any: any = a1

const bol1: boolean = a1

// unknown은 any뺴고 다안된다 애니말고 언노운 쓰자

  

// Tuple // 사실 그렇게 많이 쓰진 않는다 숫자와 갯수가 지정되어있어야함

const tuple: [string,number,boolean] = ['a',1,false]

const users: [number,string,boolean][]

= [ [1,'neo',true],[2,'ee',false]]

  

//void 리턴키워드 명시 안하는 것

  

function sayHi(msg: string):void{

    console.log(`hello ${msg}`)

}

  

const hi1: void = sayHi("kims")

//never 절대 발생하지 않는 타입 아예안쓰긴함

// 에러메시지에서 never 를 만나면 타입을 잘 확인해보자 타입지정을 잘 확인해보기

  

//union

  

let uni: string | number // 문자 또는 숫자가 할당 가능하다

uni = 'hello'

uni = 123

  

// intersection

interface A {

    name: string

}

  

interface B {

    age: number

}

// name age 둘중 어느것도 하나 빠지지 않고 들어가야 된다 .

const inter: A & B = {

    name: 'ksy',

    age: 26

}
```

# 타입 추론
> 이게 타입스크립트 언어에서 타입을 엄격하게 관리 해야 되는 것과 반대되는 개념이 절대 아니다
```ts
// 타입 추론

// 타입을 꼭 필요한 것에만 지정하면된다.

  

/*

    1) 초기화된 변수

    2) 기본값이 설정된 매개변수

    3) 반환 값이 있는 함수

*/

// 초기화된 변수

let num = 12

  

// 기본값이 지정된 매개변수 'b' 반환값이 확실한 함수 'add'

function add( a: number,b = 2){

    return a+b

}
```

# 타입 및 할당 단언 ( Assertions)

```ts
// 타입 단언

// 주저하지 않고 딱 잘라 말함 우리가 개발자가 타입스크립트한테 딱잘라말함

  
  

/**

 * 단언 키워드

 * 1. as

 *

 * 2. Non-Null 키워드 !

 *

 */

  
  

// 1) null과 HTMLBodyElement 둘다 리턴가능해서 오류뜸 왜냐 body라는게 없을수도 있으니까 하지만 개발자가 단언해서 알려주면 오류가 안뜬다

//const el = document.querySelector('body') as HTMLBodyElement

const el = document.querySelector('body')

el!.textContent = "hi " // 이렇게 쓰면 el은 null이 아니라고 단언 해준거라 오류 안뜸 하지만 이것도 문제

//왜냐하면 타입 단언이라는 거 자체가 오류를 안뜨게 막아주는 것이라 실제로 body가 없을 경우에 문제가되는것

  

//그래서 해결책이 "TYPE guard" el이 없으면 null이기에 if문으로 해주면 된다

if(el){

    el.textContent = "type guard"

}

  

// 2) toFixed는 숫자에서만 사용 가능해서 단언해줌 하지만 null도 getnumber로 들어갈수이썽서 문제

// function getNumber(x:number |null|undefined) {

//     return Number((x as number).toFixed(2))

// }

// function getNumber(x:number |null|undefined) {

//     return Number(x!.toFixed(2))

// }// 이것도 잘못된거임 사실

  

// 이게 맞는 것 타입가드로

function getNumber(x:number|null|undefined) {

    if(x){

        return Number(x.toFixed(2))

    }

}

getNumber(3.14525)

getNumber(null)//실행시키면 오류 뜨지만 여기서는 오류 안뜸

  

// 3) 타입 단언이 필요한 경우

function getValue(x: string | number , is: boolean) {

    if(is) {

        return Number((x as number).toFixed(2))

    }

    return (x as string).toUpperCase()

}

  

getValue('Hello',false)

getValue(3.14525,true)

  

// 할당 단언

  

//let num1: number

//console.log(num1) 여기선 원래 오류

  

let num1!: number

console.log(num1) // 이렇게 하면 undefined 출력된다.
```

# 타입 가드(type guards)

```ts
// 타입 가드(type Guards) 타입을 지킨다

  

function logText(el: Element){

    console.log(el.textContent)

}

  

const h1El = document.querySelector('h1')

if(h1El instanceof HTMLHeadingElement){

    logText(h1El)

}
```

# 인터페이스

```ts
// 인터페이스

  

// 선택적 속성 - ?

// 읽기전용 속성 - readonly

  

interface User{

    name : string

    age :number

    isValid?: boolean // 있어도 되고 없어도 되고

    readonly money: number

}

  

const my: User = {

    name: "mx",

    age: 26,

    money : 2099

}

  

const you: User = {

    name: "tt",

    age: 21,

    isValid : true,

    money : 2099

}

  

//you.money = 123 readonly라서 수정이 안된다

  

// 함수타입 - 호출 시그니처 => 이거 통해서 함수 타입 지정 안그러면 안된다

  

interface GetName {

    (msg:string) : string // 매개변수 : 리턴값

}

  

interface Game {

    name: string

    getName: GetName

}

interface Game2 {

    name: string

    getName: (param:string) => string// 이름은 달라도 되지만 타입과 갯수는 같아야한다

}

  

const game1: Game = {

    name:"tiktok",

    getName(msg:string) {

        console.log(msg+this.name)

        return this.name

    }

}

  

game1.getName("helloo")

  
  

// 인덱스 ㅡ가능 타입 - 인덱스 시그니처

// 숫자나 문자를 통해서 인덱싱하여서 데이터타입을 지정가능하다는 것

  

// 배열

interface Fruits {

    [items: number]: string

}

  

const fruits: Fruits = ['apple','bannna']

console.log(fruits[1])//bannna  출력

  

// 객체

interface Human {

    [key:string] : unknown

    name: string

    age: number

}

  

const ksy: Human = {

    name:'ksy',

    age:26

}

  

ksy['emails'] = ['ksyzkzk@gmail.com','test@gmail.com']

ksy['isValid'] = true

ksy.name = 'kim'

  

console.log(ksy)

  

interface Param {

    [key:string] : unknown

}

function logValues(param: Param) {

    for(const key in param){

        console.log(param[key])

    }

}

//이렇게 인덱싱 가능한 타입으로 만들어줘야된다

  

interface Man {

    [key:string]: unknown

    name:string

    age:number

}

const superman: Man ={

    name: 'kim',

    age: 26

}

  

logValues(superman)

  

// 확장(상속 )

/**

 * 인터페이스를 상속받아서 사용이 가능하다

 *

 */

  

interface UserA {

    name:string

}

  

interface UserB extends UserA {

    age: number

}

  

const neo: UserB ={

    name:'ket',

    age:26,

    isVal: true

}

//이렇게 같은 이름으로 하게 되면 추가가 된다

interface UserB {

    isVal: boolean

}
```

# 타입 별칭 (Alias)

```ts
// 타입별칭 타입의 별도 이름

  

type TypeA = string // 이렇게는 잘 안씀 이유가 없으니까

type TypeB = string | boolean | number

  

type User = {

    name: string

    age: number

} | [string,number]//튜플하고 객체를 쓰는것을 타입으로 지정했음

  

const userA: User = {

    name:"kim",

    age:26

}

  

const userB: User = ['kim1',26]

  

function someFunc(param: TypeB): TypeA {

    switch(typeof param){

        case 'string':

            return param.toUpperCase()

        case 'number':

            return param.toFixed(2)

        default:

            return "Boolean type"

    }

}

  

//타입별칭은 인터페이스를 대신해서도 사용 할 수있다

/**

 *

 * 굳이 뽑자면 인터페이스가 좀더 낫다라는 것

 */
```

# 함수 명시적 this

```ts
// 함수 - 명시적 this

  

interface Cat {

    name:string

    age:number

}

  

const cat:Cat = {

    name:'Lucy',

    age:26

}

//이렇게 this를 명시적으로 지정할수있다

  

function hello(this:Cat,msg:string){

    console.log(`Hi ${this.name} , ${msg}`)

}

  

hello.call(cat,"cute Car ")
```

# 함수 오버로딩
```ts
// 함수 오버로딩

function add(a:string,b:string): string//타입 선언

function add(a:number,b:number):number // 타입 선언

function add(a:any,b:any) { // 함수 구현

    return a+b

}

add('ehllo','2')

add(1,2)

//add('heelo',1) 이건 오류
```

# 클래스

```ts
// 클래스

  

/**'

 * 접근 제어자 - 메소드에서도 사용가능 (속성의 값이 함수면 메소드)

 * public - 어디서나 사용가능 클래스 바디에서 생략 가능함 아무것도 안붙이면 자동으로 public

 * - 하지만 매개변수 내에서는 생략 불가능

 * private - 내 클래스에서만

 * protected- 나와 파생된 후손 클래스 내에서

 */

  

class User {

    public first:string =""

    protected last:string =""

    private age:number =0

    constructor(first:string,last:string,age:number) {

        this.first=first

        this.last=last

        this.age =age

    }

    public getAll(){

        return `${this.first} is ${this.last} age: ${this.age}`

    }

}

class User2 {

    //이게 user의 축약형

    constructor(public first:string,public last:string,public age:number) {

    }

    public getAll(){

        return `${this.first} is ${this.last} age: ${this.age}`

    }

}

  

class UserB extends User{ // age는 private라서 접근이 불가능

    getAll(){

        return `${this.first} is ${this.last}`

    }

}

  

const user = new User('kim','sungyep',26)

console.log(user.first)

//console.log(user.last) age 둘다 오류 임
```

# 제네릭 

```ts
// 제네릭(Generic) <> 이게 제네릭  

/**

 *  함수

 * 타입 추론을 통해서 하는 것

 */

  

interface Obj {

    x:number

}

type Arr = [number,number]

  

function toArray<T>(a:T,b:T) {

    return [a,b]

}

  

console.log(

    toArray('Neo','kim'),

    toArray(1,2),

    toArray(true,false),

    //toArray('12',123) 이것도 안됨 '12'여기서 스트링으로 추론해서 뒤 b도 스트링이여야된다.

    //toArray({x:1},{y:2})

    toArray({x:1},{x:2}),

    toArray([1,2],[3,4,5]),//타입추론을 number[] 이걸로해서 3개 들어가도 문제 없는 것

    toArray<Arr>([1,2],[3,5])

)

  

/**

 * 클래스

 */

  

class User<P>{

    constructor(public payload: P){}

    getPayload(){

        return this.payload

    }

}

  

interface Atype {

    name: string

    age: number

}

interface Btype{

    name:string

    age:number

    email: string[]

}

  

const userA = new User<Atype>({

    name:'kim',

    age:13

})

  

const userB = new User<Btype>({

    name:"lel",

    age:23,

    email:['ksy@gmail.com']

})

  

console.log(userA)

console.log(userB

)

console.log(userA.getPayload())

  

/**

 *

 * 인터페이스

 * 제약조건

 */

  

interface MyData<T extends string | number> {

    name: string

    value: T

}

  

const dataA:MyData<string> = {

    name:"dataA",

    value: 'Hello'

}

  

const dataB:MyData<number> = {

    name:"dataB",

    value: 2

}
```

# 패키지의 타입선언 

> 확장자 .d.ts 가 dts 파일이고 여기에는 내가 사용하려는 것의 대한 타입을 선언해줘야된다.

```ts
declare module 'lodash'{

    interface Lodash {

        camelCase: (str:string) => string

        snakeCase: (str:string) => string

        kebabCase: (str:string) => string

    }

    const _: Lodash

    export default _

}


```

```ts

// 파일확장자

//이때 만약에 파일명이 dts인데 이름이 lodash가 아니면 얘가 못찿는다 그럴때는 따로 path를 지정해야됨 이렇게

  

/// <reference path="./lodash.d.ts"/>

import _ from 'lodash'

  

const str= 'my color is red'

  

console.log(_.camelCase(str))

console.log(_.snakeCase(str))

console.log(_.kebabCase(str))
```


## 그러나 요즘은 Definitely typed 라고 해서 npm install로 가능하게 해놓은게 존재한다 요즘은 dts 파일 잘 안만든다 

> npm info @types/이름 

으로 검색하여서 만약에 존재하면 일일이 위에처럼 작성 안해도 

> npm i @types/이름 -D 

하면 끝 

이러면 import 만 해도 오류 안뜸 

```ts
  

import _ from 'lodash'

  

const str= 'my color is red'

  

console.log(_.camelCase(str))

console.log(_.snakeCase(str))

console.log(_.kebabCase(str))
```

### 그런 다음 tsconfig 파일에 typeRoot추가

```ts
{

    "compilerOptions": {

        "target": "ES2015",

        "module": "ESNext",

        "moduleResolution": "Node",

        "esModuleInterop": true,

        "lib" : ["ESNext","DOM"],

        "strict": true,

        "typeRoots": [

            "./node_modules/@types"

        ]

    },

    "include": [

        "src/**/*.ts"

    ],

    "exclude": [

        "node_modules"

    ]

}
```

# 타입 가져오기 내보내기 

```ts
// 타입 가져오기 내보내기

import { getAll,User } from "./user";

  

const user1: User = {

    firstName: 'kim',

    lastName: 'sungyeop',

    age:27

}

  

const full = getAll(user1)

console.log(full)

console.log(user1.age)


---------------------------------------------------------------------------------
export interface User {

    firstName: string

    lastName: string

    age: number

}

  

export function getAll(user: User) {

    return `${user.firstName} ${user.lastName}`

}
```


# tsconfig 구성옵션 


https://www.typescriptlang.org/ko/docs/handbook/tsconfig-json.html#%EC%83%81%EC%84%B8-%EC%84%A4%EB%AA%85-details


> include : 컴파일할 파일 경로 목록 

> exclude: 컴파일에서 제외할 파일 경로 목록 

# 데코레이터 

데코레이터는 일종의 **함수** 이다.

데코레이터는 말 그대로 코드 조각을 장식해주는 역할을 하며, 타입스크립트에서는 그 기능을 함수로 구현하는 것이다.

예를들어 메소드 / 클래스 / 프로퍼티 / 파라미터 위에 ~~@함수~~ 를 장식해줌으로써, 코드가 실행(런타임)이 되면 데코레이터 함수가 실행되어, 장식한 멤버를 보다 파워풀하게 꾸며주는 것으로 이해하면 된다.
https://www.typescriptlang.org/ko/docs/handbook/decorators.html
출처: [https://inpa.tistory.com/entry/TS-📘-타입스크립트-데코레이터-개념-사용법-정리#타입스크립트_decorator_란](https://inpa.tistory.com/entry/TS-%F0%9F%93%98-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%EA%B0%9C%EB%85%90-%EC%82%AC%EC%9A%A9%EB%B2%95-%EC%A0%95%EB%A6%AC#%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8_decorator_%EB%9E%80) [Inpa Dev 👨‍💻:티스토리]