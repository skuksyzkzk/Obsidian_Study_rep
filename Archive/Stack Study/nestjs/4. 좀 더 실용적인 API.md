

# DTO

> Data Transfer Object 

게층 간 데이터 전송을 위해 사용되는 객체

1. API 요청에서 받아온 데이터를 타입에 맞게 바인딩 및 유효성 검사
2. Service 계층과 controller 계층 사이의 데이터를 전달
3. Response 객체로 데이터를 클라이언트에 전달

## nest js에서는 클래스로 선언 
> 데이터 유효성 검사가 강력하다 
> class validator 데코레이터로 가능한 것


# 게시글 생성 DTO 구현 

> yarn add class-validator class-transformer 

치기 

```ts
import { IsNotEmpty, MaxLength, MinLength } from "class-validator";

  

export class CreateBoardDto{

    @IsNotEmpty()

    @MinLength(2)

    @MaxLength(20)

    name: string;    

    @IsNotEmpty()

    content: string;

}
```

여기까지 해서 적용은 안된다 

# pipe

결국 클라이언트의 요청이 라우터 핸들러로 도착하기전에 검사하는 것 

파이프 역할 

1. 유효성 검사 HTTP 요청 처리 할 때 데이터가 DTO에 명시된 형태와 일치하는지 확인
2. 데이터변환 : 입력된 데이터를 다른 형태로 변환 
	1. 토큰정보가 헤더에 있으면 복호화해서 유저의 정보를 처리 
	2. 이때 파이프에서 유저 정보 추출하는 로직 추가해서 한다 


## Validation pipe 

유효성 검사할때 쓰이는 것 

메소드 단에서 적용시 @Body안에

```ts

import { IsOptional, MaxLength, MinLength } from "class-validator";

  

export class UpdateBoardDto {

    @MinLength(2)

    @MaxLength(20)

    @IsOptional()

    name? : string;

    @IsOptional()

    content?: string;

}
```

이렇게 업데이트 DTO를 구현했는데 이렇게 새롭게 생성하는 것 말고도 ts의 장점을 활용해서 extends 해서 사용 할 수 도 있따

```ts
// export class UpdateBoardDto extends PartialType(CreateBoardDto) {};

// export class UpdateBoardDto extends PickType(CreateBoardDto.['name']) {};

// export class UpdateBoardDto extends OmitType(CreateBoardDto['name') {};
```

이렇게 부분적으로 partialType사용 할 경우 가져오는 기존 DTO에서 isnotEmpty이런부분은 제거 해야된다 왜냐면 partialType는 가져올 때 전부 optional로 가져오기 때문이다

Pick은 저 심볼만 가져다 쓰고 Omit은 해당 심볼을 제거한걸 사용한다

## apiproperty로 swagger
```ts
import { ApiProperty } from "@nestjs/swagger";

import { IsNotEmpty, MaxLength, MinLength } from "class-validator";

  

export class CreateBoardDto{

    @IsNotEmpty()

    @MinLength(2)

    @MaxLength(20)

    @ApiProperty( {

        description: '이름',

        required: true,

        example: '홍길동',

    })

    name: string;    

    @IsNotEmpty()

    @ApiProperty({

        description: '내용',

        required: true,

        example: '내용들~',

    })

    content: string;

}
```

# nest js 데코레이터

1. 클래스-클래스 상단에 붙음
	1. @Module()
	2. @Controller()
	3. @Injectable()
2. 메서드-@get,post이런것들
3. 매개변수
	1. @Req,@Res
	2. @Body,@Query,@Param 
4. 속성
	1. TypeORM에서 많이 사용된다.

## 커스텀 데코레이터를 만들기

> 주로 매개변수나 메소드 데코레이터를 많이 만든다 

IP checking하는 데코레이터를 만들어 보자 

# Exception Filters를 통한 예외처리

클라이언트 요청이 들어오고 라우터핸들러에서 동작하다 예외를 처리 할 경우 사용된다.

```ts
@Get()

  getHello(

    @Ip() ip: string

  ): string {

    // console.log(ip);

    // return this.appService.getHello();

    throw new HttpException('NotFound',HttpStatus.NOT_FOUND);

  }
 
```

# loggerModule로 로깅처리

```ts

private readonly logger = new Logger();

  @Get()

  getHello(

    @Ip() ip: string

  ): string {

    console.log(ip);

    this.logger.log(ip);

    return this.appService.getHello();

  }
```


# configmodule을 적용해서 환경설정 적용

.env 파일을 효율적 관리 가능하다 

# 