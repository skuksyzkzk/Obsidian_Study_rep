
nest js CLI를 통해 소스를 생성하면 자동으로 파일생성과 의존관계 생성해준다

## main.ts

nest js 의 진입점 

NestFactory 클래스를 통해서 nest js 앱을 생성한다 
미들웨어 및 모듈을 등록하고 http서버를 시작

> nest js 에서 모듈을 사용하고자 하는 경우 AppModule에 등록이 되어 있어야한다.

# Module
A module is a class annotated with a `@Module()` decorator. The `@Module()` decorator provides metadata that **Nest** makes use of to organize the application structure.

|   |   |
|---|---|
|`providers`|the providers that will be instantiated by the Nest injector and that may be shared at least across this module|
|`controllers`|the set of controllers defined in this module which have to be instantiated|
|`imports`|the list of imported modules that export the providers which are required in this module|
|`exports`|the subset of `providers` that are provided by this module and should be available in other modules which import this module. You can use either the provider itself or just its token (`provide` value)|

## Feature Modules (기능 모듈)

앱의 특정 기능을 캡슐화 
컨틀롤러 서비스 레포지를 그룹화 해서 씀 


## shared module (공유모듈)

앱 전반에 공유되는 기능 
데이터베이스 접속등 이런 기능은 공통으로 사용하고 
export함

## global module
When you want to provide a set of providers which should be available everywhere out-of-the-box (e.g., helpers, database connections, etc.), make the module **global** with the `@Global()` decorator.The `@Global()` decorator makes the module global-scoped. Global modules should be registered **only once**, generally by the root or core module. In the above example, the `CatsService` provider will be ubiquitous, and modules that wish to inject the service will not need to import the `CatsModule` in their imports array.

모듈을 전역적으로 사용하게 해준다 임포트없이 사용가능하게 해줌 


# controller
## Routing
들어오는 요청을 처리하고 클라이언트에게 응답을 반환하는 역할 
A controller's purpose is to receive specific requests for the application. The **routing** mechanism controls which controller receives which requests. Frequently, each controller has more than one route, and different routes can perform different actions.

In order to create a basic controller, we use classes and **decorators**. Decorators associate classes with required metadata and enable Nest to create a routing map (tie requests to the corresponding controllers).

> 기본적으로 rest api 엔드포인트를 노출하는데 사용 
In the following example we'll use the `@Controller()` decorator, which is **required** to define a basic controller. We'll specify an optional route path prefix of `cats`. Using a path prefix in a `@Controller()` decorator allows us to easily group a set of related routes, and minimize repetitive code. For example, we may choose to group a set of routes that manage interactions with a cat entity under the route `/cats`. In that case, we could specify the path prefix `cats` in the `@Controller()` decorator so that we don't have to repeat that portion of the path for each route in the file.

데코레이터 안에 문자열은 그게 path prefix임 라우팅에
```typescript
import { Controller, Get } from '@nestjs/common';

@Controller('cats')
export class CatsController {
  @Get()
  findAll(): string {
    return 'This action returns all cats';
  }
}
```
The `@Get()` HTTP request method decorator before the `findAll()` method tells Nest to create a handler for a specific endpoint for HTTP requests. The endpoint corresponds to the HTTP request method (GET in this case) and the route path. What is the route path? The route path for a handler is determined by concatenating the (optional) prefix declared for the controller, and any path specified in the method's decorator. Since we've declared a prefix for every route ( `cats`), and haven't added any path information in the decorator, Nest will map `GET /cats` requests to this handler. As mentioned, the path includes both the optional controller path prefix **and** any path string declared in the request method decorator. For example, a path prefix of `cats` combined with the decorator `@Get('breed')` would produce a route mapping for requests like `GET /cats/breed`.

또한 이처럼 http 메서드를 데코레이터로 제공한다

그러니까 라우팅할때 편하게

/cats 로 오면 그 안에서도 get 이나 post냐를 구분해서 쓸수있다는거지 하나의 cats안에 또한 

/cats/breed 이렇게 get 으로 오면 @Get('breed') 이러면 되서 편하기도 하고 

## 매개변수와 쿼리 스트링 

![[Pasted image 20240216160431.png]]




# provider
Providers are a fundamental concept in Nest. Many of the basic Nest classes may be treated as a provider – services, repositories, factories, helpers, and so on. The main idea of a provider is that it can be **injected** as a dependency; this means objects can create various relationships with each other, and the function of "wiring up" these objects can largely be delegated to the Nest runtime system.

Providers are plain JavaScript classes that are declared as `providers` in a [module](https://docs.nestjs.com/modules).

> provider는 모듈에 정의가 되어 있어야 된다 
# service
일반적인 비지니스 로직을 담당한다 
컨트롤러가 클라이언트의 요청을 처리하는데 필요한 작업을 처리하고 
데이터베이스의 데이터를 가져오거나 외부 api 호출등의 데이터처리

> @Injectable() 이걸로 클래스가 주입 가능한 상태가 된다


## **Nest IoC Container**

IoC Container는 Provider를 등록하고 관리하는 객체이다.

Provider는 NestJS의 라이프 사이클과 동기화된 Scope를 가지며

프로그램이 시작될 때 모든 종속성을 처리한다.

Provider는 의존성 주입을 통해 다른 클래스와 관계를 맺을 수 있는데,  
IoC Container는 Provider의 메타데이터를 분석하여 의존성 그래프를 생성한다.

  
IoC Container는 의존성 그래프에 따라 필요한 Provider를 인스턴스화하고 주입하며,

이 과정에서 @Injectable 데코레이터가 사용된다.  
또한 인스턴스화된 Provider를 저장하고, 참조할 수 있게 해주는데 이때는 @Inject 데코레이터가 사용된다.

  
**즉, IoC Container는 Provider를 컨테이너에 등록하고, 필요할 때마다 Provider 인스턴스를 생성하여**

**생성과 관리를 개발자가 아닌 프레임워크가 수행하는 역할을 하게 된다**


해당 클래스는 nest cli에서 관리 주입가능한 클래스로 선언된 컨트롤러에서 주입된다 
nest 자체에서 app서비스의 인스턴스를 생성한것 

# DI 의존성 주입

외부에서 주입받아서 클래스나 컴포넌트 사용
모듈간의 결합도 줄인다

생성자 매개변수를 통해서 의존성 정의 

**의존성 주입이란,**

추상에만 의존하고 구체에는 의존하지 않는다는 것.

간단히 말해 의존 관계를 객체 내부에서가 아닌 외부에서 결정하는 것으로,

사용할 객체에 대한 reference를 외부에서 제공해준다는 것이다.

```java
public class UserService { // private final UserRepository users = new MemoryUserRepository(); 
private final UserRepository users = new UserRepository(); ... }
```

``` java
public class UserService { /** * DI 가 가능하도록 코드를 변경 */ 
private final UserRepository users; 
public UserService(UserRepository users) {
this.users = users; 
} 
... 
}
```

이렇게 코드를 변경하게 되면 UserService 내에서 의존 관계의 객체를 직접 정해주는 것이 아닌

외부에서 결정해주게 된다.

Service가 호출되는 그 시점에 의존관계가 설정되며 

이 경우엔 객체 자체가 아니라 런타임에서 프레임 워크에 의해 주입되므로

제어권을 외부. 즉 프레임 워크가 가지게 되는 것이다.

**IOC(Inversion of Control)**의 개념이 바로 이것이다.
https://hou27.tistory.com/entry/Dependency-Injection%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85-DI%EB%9E%80




