# 라이브러리는 state가 없다
> 그렇기 때문에 함수가 pure로 선언되어있는 것 

 
  기존에 만들던 스마트 컨트랙과 다른 종류의 스마트 컨트랙이라 할  수 있습니다. 라이브러리를 사용함으로써 몇가지 이점과 제한사항이 있습니다.

### **이점**

### **1. 재사용**
:블록체인에 라이브러리가 배포되면, 다른 스마트 컨트랙들에 적용가능.

### **2. 가스 소비 줄임**
: 라이브러리는 재사용가능 한 코드, 즉 여러개의 스마트 컨트랙에서 공통으로 쓰이는 코드를 따로 라이브러리 통해서 배포 하기에, 다른 스마트 컨트랙에 명시를 해주는것이 아니라, 라이브러리를 적용만 하면 되기에 가스 소비량을 줄일 수 있다. 왜냐하면, 가스는 스마트 컨트랙의 사이즈/길이에 영향을 많이 받기 때문이다. 

### **3.데이터 타입 적용:**
라이브러리의 기능들은 데이터 타입에 적용할 수 있기에, 좀 더 쉽게 사용할 수 있다.

### **제한사항**

### **1. fallback 함수 불가:**
fallback 함수를 라이브러리 안에 정의를 못 하기에, 이더를 갖고 있을 수 없습니다.
### **2. 상속 불가**
### **3. payable 함수 정의 불가**


# 라이브러리를 import 해오는 것은 두가지의 경우가 있다.

1. 계약서에 **internal**로 표시된 라이브러리 기능을 사용할 경우 함수 내부의 코드가 컨트랙트 자체에 복사돼 컨트랙트와 함께 컴파일된다.

 2.  .계약이 **external** 또는 **public** 으로 표시된 라이브러리 기능을 사용하는 경우 라이브러리는 자체 주소로 배포되어야 한다. 그러면 컨트랙트는 도서라이브러리 주소로 연결된다. 런타임에서, 컨트랙트는 라이브러리 함수에 접근하기 위해 DELEGATECALL (an EVM opcode)을 사용하여 메시지를 생성할 것이다.

라이브러리를 import 해올때, 해당 코드는 계약 코드와 동일한 **context**에서 실행된다. 라이브러리가 바이트코드로 컴파일되면 코드는 실제로 컨트랙트 내부에서 실행된다. 라이브러리가 연결되면 **DELEGATECALL** opcode는 컨트랙트 context 를 유지하면서 라이브러리를 호출한다.

라이브러리가 자체적으로 배포되어야 할 때, 솔리디티 컴파일러는 **컨트랙트 바이트코드** 안에 placeholder을 삽입한다: